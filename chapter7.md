# Smart Contracts and Solidity
이더리움은 2가지 계정이 있음: EOA, 컨트랙트 계정  
EOA 계정은 사용자, 특히 지갑 어플같은 이더리움 외부 플랫폼에 의해서 컨트롤됨  
컨트랙트 계정은 이더리움 가상 머신에 의해서 실행되는 프로그램 코드에 의해서 컨트롤 됨  
EOA 는 연동되는 코드나 데이터 저장 매체없는 단순 계정이고,  
컨트랙트 계정은 연동 코드나 데이터 저장매체를 가진다  

EOA 는 트랜잭션에 의해서 컨트롤되고, 당연히 비밀키가 필요함    
컨트랙트 계정은 비밀키가 필요없고, 스마트 컨트랙트 코드의 의해서 컨트롤됨  
위 두개의 계정 타입은 이더리움 주소의 의해서 구분된다  
본 챕터에서는 컨트랙트 계정에 대해서 다룬다  

# What is a Smart Contract?
1990년대에 암호학자 Nick Szabo 가 "약속의 집합" 이라고 컨트랙트를 정의  
분산 블록체인 플래폼 등장후에 계념의 확장됨  
이더리움 스마트컨트랙트는 스마트하지도 법적인 컨트랙트도 아니다  
이더리움에서는 스마트컨트랙트를 변경할수없는 컴퓨터 프로그램이라고 봄  
해당 프로그램은 이더리움 가상 머신의 컨텍스트안에서 결정론적으로 작동함  

* Computer programs
  스마트 컨트랙트는 컴퓨터 프로그램이다. "컨트랙트" 단어는 본 문장에서 법률적 의미가 없음  
  
* Immutable 
  일단 배포되면 스마트 컨트랙트 코드는 변경할 수 없다. 스마트 컨트랙트를 변경하기 위해서 유일한 방법은 새로운 인스턴스를 배포하는 것임  
  
* Deterministic
  스마트 컨트랙트 실행 결과는 누가 실행하든 같아야 함. 
  
* EVM context
  스마트 컨트랙트 매우 제한된 실행 컨텍스트를 사용한다. 자신의 상태와 트랜잭션의 컨텍스트, 그리고 가장 최신의 블록 정보에 접근할 수 있음  
  
* Decentralized world computer
  EVM 은 모든 이더리움 노드 위에서 로컬 인스턴스로서 작동한다. 한 시스템으로서 하나의 싱글 월드 컴퓨터로서 작동함  
  
# Life Cycle of a Smart Contract
스마트컨트랙트는 솔리디티 같은 하이 레벨 언어로 작성됨  
EVM 에서 작동시키기 위해서는 로우 레벨 바이트코드로 컴파일 돼야함  
컴파일 이후에 특별 컨트랙트 생성 트랜잭션을 사용해서 이더리움 플랫폼에 배포됨  
특별 컨트랙트 생성 주소 즉, 0x0 로서 구분 됨.  
각 컨트랙트는 이더리움 주소에 의해 구분됨  
위 주소는 원천 계정 함수와 nonce 를 통해서 컨트랙트 생성 트랜잭션으로 부터 유도됨  
컨트랙트의 이더리움 주소는 트랜잭션의 수령자 필드에서 사용됨  
위 수령자는 컨트랙트의 펀드를 보내거나 컨트랙트 함수를 호출하는 용도임  
EOA 와는 다르게 새로운 스마트 컨트랙트 만드는 계정은 키와 전혀 연관되지 않음  
컨트랙트 생성자도 프로토콜 레벨에서도 어떤 특별한 권한이 없다  
당연히 스마트 컨트랙트 안에 명확히 코딩을 한다해도 권한을 줄 수 없음  
또한 컨트랙트 계정은 비밀키도 존재하지 않음  

컨트랙트는 오직 트랜잭션의 호출에 의해서 작동함  
모든 스마트 컨트랙트는 EOA 의해 촉박한 트랜잭션에 의해서 실행됨  
컨트랙트는 또다른 컨트랙트를 호출할 수 있고, 연속으로 다른 컨트랙트 호출함  
그러나 당연히 첫 컨트랙트는 항상 EOA 의해 만들어진 트랜잭션의 의해서 호출됨  
컨트랙트는 결코 자기 자신을 호출하거나, 백그라운드에서 작동할 수 없음  
컨트랙트는 어떤 상황에서도 병렬적으로 실행되지 않음  
이더리움 월드 컴퓨터는 싱글 스레드 머신임  

트랜잭션은 


