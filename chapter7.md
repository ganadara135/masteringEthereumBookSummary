# Smart Contracts and Solidity
이더리움은 2가지 계정이 있음: EOA, 컨트랙트 계정  
EOA 계정은 사용자, 특히 지갑 어플같은 이더리움 외부 플랫폼에 의해서 컨트롤됨  
컨트랙트 계정은 이더리움 가상 머신에 의해서 실행되는 프로그램 코드에 의해서 컨트롤 됨  
EOA 는 연동되는 코드나 데이터 저장 매체없는 단순 계정이고,  
컨트랙트 계정은 연동 코드나 데이터 저장매체를 가진다  

EOA 는 트랜잭션에 의해서 컨트롤되고, 당연히 비밀키가 필요함    
컨트랙트 계정은 비밀키가 필요없고, 스마트 컨트랙트 코드의 의해서 컨트롤됨  
위 두개의 계정 타입은 이더리움 주소의 의해서 구분된다  
본 챕터에서는 컨트랙트 계정에 대해서 다룬다  

# What is a Smart Contract?
1990년대에 암호학자 Nick Szabo 가 "약속의 집합" 이라고 컨트랙트를 정의  
분산 블록체인 플래폼 등장후에 계념의 확장됨  
이더리움 스마트컨트랙트는 스마트하지도 법적인 컨트랙트도 아니다  
이더리움에서는 스마트컨트랙트를 변경할수없는 컴퓨터 프로그램이라고 봄  
해당 프로그램은 이더리움 가상 머신의 컨텍스트안에서 결정론적으로 작동함  

* Computer programs
  스마트 컨트랙트는 컴퓨터 프로그램이다. "컨트랙트" 단어는 본 문장에서 법률적 의미가 없음  
  
* Immutable 
  일단 배포되면 스마트 컨트랙트 코드는 변경할 수 없다. 스마트 컨트랙트를 변경하기 위해서 유일한 방법은 새로운 인스턴스를 배포하는 것임  
  
* Deterministic
  스마트 컨트랙트 실행 결과는 누가 실행하든 같아야 함. 
  
* EVM context
  스마트 컨트랙트 매우 제한된 실행 컨텍스트를 사용한다. 자신의 상태와 트랜잭션의 컨텍스트, 그리고 가장 최신의 블록 정보에 접근할 수 있음  
  
* Decentralized world computer
  EVM 은 모든 이더리움 노드 위에서 로컬 인스턴스로서 작동한다. 한 시스템으로서 하나의 싱글 월드 컴퓨터로서 작동함  
  
# Life Cycle of a Smart Contract
스마트컨트랙트는 솔리디티 같은 하이 레벨 언어로 작성됨  
EVM 에서 작동시키기 위해서는 로우 레벨 바이트코드로 컴파일 돼야함  
컴파일 이후에 특별 컨트랙트 생성 트랜잭션을 사용해서 이더리움 플랫폼에 배포됨  
특별 컨트랙트 생성 주소 즉, 0x0 로서 구분 됨.  
각 컨트랙트는 이더리움 주소에 의해 구분됨  
위 주소는 원천 계정 함수와 nonce 를 통해서 컨트랙트 생성 트랜잭션으로 부터 유도됨  
컨트랙트의 이더리움 주소는 트랜잭션의 수령자 필드에서 사용됨  
위 수령자는 컨트랙트의 펀드를 보내거나 컨트랙트 함수를 호출하는 용도임  
EOA 와는 다르게 새로운 스마트 컨트랙트 만드는 계정은 키와 전혀 연관되지 않음  
컨트랙트 생성자도 프로토콜 레벨에서도 어떤 특별한 권한이 없다  
당연히 스마트 컨트랙트 안에 명확히 코딩을 한다해도 권한을 줄 수 없음  
또한 컨트랙트 계정은 비밀키도 존재하지 않음  

컨트랙트는 오직 트랜잭션의 호출에 의해서 작동함  
모든 스마트 컨트랙트는 EOA 의해 촉박한 트랜잭션에 의해서 실행됨  
컨트랙트는 또다른 컨트랙트를 호출할 수 있고, 연속으로 다른 컨트랙트 호출함  
그러나 당연히 첫 컨트랙트는 항상 EOA 의해 만들어진 트랜잭션의 의해서 호출됨  
컨트랙트는 결코 자기 자신을 호출하거나, 백그라운드에서 작동할 수 없음  
컨트랙트는 어떤 상황에서도 병렬적으로 실행되지 않음  
이더리움 월드 컴퓨터는 싱글 스레드 머신임  

트랜잭션은 원자적임. 성공적인 트랜잭션 처리 종료는 다음과 같이 3가지임  
1) 트랜잭션이 EOA 에서 또다른 EOA로 보내짐
2) 트랜잭션이 EOA 에서 컨트랙트로 보내짐
3) 트랜잭션이 EOA 에서 컨트랙트로 보내짐. 본 컨트랙트는 에러메시지를 전파하는 방식으로 다른 컨트랙트를 호출함  
4) 트랜재션이 EOA 에서 컨트랙트로 보내짐. 본 컨트랙트는 에러메시지를 전파하지 않는 방식으로 다른 컨트랙트를 호출함  

위 과정중에 계좌 잔액, 상태 변수 같은 글로벌 상태 변화는 모두 기록되고, 트랜잭션이 중기되면 모든 효과가 롤백됨.  
실패한 트랜잭션은 기록되고, 사용된 가스 만큼의 이더는 요청자의 계정에서 공제됨  
컨트랙트 코드는 변경될 수 없지만, 지워질 순 있다.   
지워진 컨트랙트 주소에 보내진 트랜잭션은 어떤 코드도 실행하지 않는다  
컨트랙트를 지우기 위해서는 EVM opcode 인 SELFDESTRUCT 를 실행하면 됨.  
SELFDESTRUCT 는 해당 기능이 컨트랙트 코드내에 포함돼 있어야 가능함  
컨트랙트를 지운다는 것이 트랜잭션 히스토리를 지운다는 건 아님  

# Introduction to Ethereum High-Level Languages
EVM 은 EVM 바이트코드를 작동시키는 가상 머신임   
x86_64 와 같은 머신 코드를 운영하는 CPU 와 유사함  

EVM 바이트코드는 직접 프로그래밍하기 어려우므로 상위 레벨 언어로 프로그램을 작성해서 바이트코드로 컴파일함.  

프로그래밍 언어는 크게 2가지 패러다임으로 분류됨: 선언적, 명령적 또는 기능적, 절차적.  
선언적 프로그래밍은 한 프로그램의 로직을 나타내는 기능을 작성하지 흐름을 작성하지 않음  
선언적 프로그래밍은 사이드 효과가 없어야 하는 곳에 주로 사용됨  
선언적 프로그래밍 언어는 Haskell, SQL 등이 있음  
명령적 프로그래밍은 개발자가 로직과 흐름을 결합하는 절차적 집합을 작성함  
명령형 프로그래밍 언어는 C++ 과 Java 가 있음  
위 특징을 모두 사용하는 하이브리드 언어가 Lisp, JavaScrpt, Python 가 있음  
명령형 언어에서 선언형 패리다임을 사용할 수 는 있는 코드가 지저분함  
반면에 순수 선언형 언어는 명렁형 패러다임을 적용할 수 없음  
순수한 선언형 언어는 변수를 사용하지 않는다  

명령형 언어는 개발자들이 주로 사용하고 있으나, 정확히 기대한 방식으로 프로그램을 작동시키기가 어렵다.  
어떤 상태를 변경 시키기 위해서 어떤 부분을 어떤 방식으로도 변경할 수 있는 능력은 프로그램 실행을 추론하기 어렵게 만들어 원하지 않는 부작용을 일으킨다  
반면에 선언형 프로그래밍은 프로그램이 어떻게 작동할 것인지 이해하기 쉽게 만들고, 부작용이 없으며, 프로그램 실행 영역들을 분리하여 이해할 수 있음  

따라서 선언적 언어가 일반 목적의 언어보다 스마트컨트랙트에 중요하나,  
Solidity 는 명령형 언어이다.  

현재 스마트컨트랙트를 지원하는 상위 레벨 프로그래밍 언어는 다음과 같음  
* LLL
  함수형 프로그래밍 언어이고, 문법은 Lisp 같음. 널리 사용되지 않음.  
  
* Serpent
  절차적 프로그래밍 언어이고 Python 과 같은 문법임.
  
* Solidity
  절차적 프로그래밍 언어이고 문법은 JavaScript, C++ or Java 같음.
  
* Vyper
  가장 최신의 개발된 언어이고 문법은 Python 과 유사함. Python 의 순수 함수형 규칙을 사용함.  
  
* Bamboo
  Erlang 에 영향을 받은 선언형 언어임. 명확한 상태 전황과 반복문을 사용 안함. 따라서 부작용을 줄이고 추적가능성을 높였음. 최신 언어라 확산되지 않음  
  
본 과정에서는 Solidity 를 다룰 것임  

# Building a Smart Contract with Solidity


