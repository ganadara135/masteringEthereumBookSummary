# Wallets
지갑의 의미가 다양함  
상위 개념에선 이더리움과 주 사용자 인터페이스로서 소프트웨어 애플리케이션이다  
범위를 좁혀서 개발자 관점에선 사용자 키를 관리하는 프로그램임  
본 챕터에서는 개발자 관점에서만 다룬다  

지갑은 이더리움에서 몇가지 다른 것을 설명 한다.  
높은 수준에서 지갑은 이더리움의 기본 사용자 인터페이스 역할을 하는 소프트웨어 애플리케이션이다.  
지갑은 사용자의 돈에 대한 액세스, 키 및 주소 관리, 잔액 추적, 트랜잭션 생성 및 서명을 제어한다.  
또 일부 이더리움 지갑은 ERC20 토큰과 같은 계약과도 상호작용할 수 있다.  
좁게 보면 개발자 관점에서, 지갑은 사용자의 키를 저장하고 관리하는 데 사용되는 시스템을 가리킨다.  
모든 지갑에는 키를 관리하는 구성 요소가 있다. 일부 지갑은 그게 전부이다. 다른 지갑은 훨씬 더 광범위한 범주의 일부입니다. 브라우저 는 이더리움 기반 분산 애플리케이션에 대한 인터페이스 인 DApp 또는 분산형 애플리케이션챕터 에서 자세히 살펴볼 것.  
지갑이라는 용어로 합쳐진 다양한 카테고리 사이에는 명확한 구분선이 없다.   
이 챕터에서는 개인 키의 컨테이너와 이러한 키를 관리하기 위한 시스템으로 지갑을 살펴보기로 한다.  

# Wallet Technology Overview
이 섹션에서는 사용자 친화적이고, 안전하고, 유연한 이더리움 지갑을 만드는 데 사용되는 다양한 기술을 요약한다.  
지갑을 설계할 때 고려해야할 중요사항은 편의성과 개인 정보 보호 사이의 균형 이다.  
가장 편리한 이더리움 지갑은 모든걸 재사용 할 수 있는 개인 키와 주소가 있는 지갑 이다.  
이런 솔루션은 쉽게 모든 거래를 추적하고 연관시킬 수 있기 때문에 개인정보에 취약하다.  
모든 거래에 새로운 키를 사용하는 것이 개인정보보호를 위해 가장 좋지만 관리하기가 어렵다.  
올바른 균현을 이루기는 어렵지만 좋은 지갑 설계가 중요한 이유임.  
이더리움에 대한 일반적 오해는 이더리움 지갑에 이더나 토큰이 들어 있다는 것이다.   엄밀히 말하면, 지갑에는 열쇠만 있다. 이더 또는 다른 토큰이 이더리움 블록체인에 기록된다.  
사용자는 지갑에 있는 키로 트랜잭션에 서명하여 네트워크에서 토큰을 제어한다.  
어떤 의미에서 이더리움지갑은 키체인이다. 지갑이 보유한 키가 이더 나 토큰을 다른 사람에게 전송하는 데 필요한 유일한 것임을 감안할 때 실제로 이러한 구분은 무관하다.   
차이가 중요한 부분은 기존 은행의 중앙 집중식 시스템 (본인과 은행 만이 계좌에있는 돈을 볼 수 있고 거래를 하려고 자금 이동하기위해 은행에 요청)에서 사고 방식을 바꾸는 것입니다.  
블록 체인 플랫폼의 탈 중앙화 시스템 (모든 사람이 계정의 이더 잔고를 볼 수 있지만 계정 소유자를 모르고 모든 사람이 소유자가 거래를 위해 자금을 제정).   
실제로 이것은 지갑이 필요 없이 계좌를 확인할 수 있는 독립적인 방법이 있다는 것을 의미한다.   
게다가, 만약 당신이 사용하기 시작한 지갑 앱이 싫어진다면, 당신은 당신의 계정 처리를 현재의 지갑에서 다른 지갑으로 옮길 수 있다.  
노트	이더 리움 지갑은 이더 나 토큰이 아닌 키가 있다. 지갑은 개인 키와 공개 키 쌍을 포함하는 키 체인과 같다.   
사용자는 개인 키로 거래에 서명하여 자신이 에테르를 소유하고 있음을 증명한다. 에테르는 블록 체인에 저장된다.  
지갑에는 두 가지 주요 유형이 있는데, 지갑에 들어 있는 키가 서로 연관되어 있는지 여부에 따라 구별된다.  

-비결정론적지갑  
각 키가 서로 다른 난수에서 독립적으로 생성, 키는 서로 관련이 없다. 이 유형의 지갑은 "Just a Bunch of Keys"라는 문구에서 JBOK 지갑이라고한다.  

-결정론적지갑  
모든 키는 seed 라고하는 단일 마스터 키에서 파생, 모든 열쇠는 서로 연관되어 있으며, 원래 seed가 있으면 다시 생성 할 수 있다.  
결정론적지갑은 다양한 키 파생방법이 있다.  
가장 일반적인 방법은 계층적결정적지갑에서 설명된 대로 트리와 같은 구조를 사용한다  
휴대폰을 도난당하거나 변기에 떨어뜨리는것과 같은 데이터 손실 사고에 대비하여 결정론적지갑을 조금더 안전하게 만들기위해, seed는  사고 발생시 사용할 수 있도록 (영어 또는 다른 언어)으로 인코딩됩니다.  
이를 지갑의 니모닉 코드 단어라고 한다.  
누군가 당신의 니모닉 코드 단어를 손에 넣으면 지갑을 다시 만들어서 당신의 이더와 스마트 계약에 접근 할 수 있다.  
따라서 복구 단어 목록에 매우주의해야 한다. 컴퓨터 나 전화에 전자적으로 파일로 저장하지 마십시오.  
종이에 적어두고 안전한 곳에 보관해야한다.  
다음 몇 섹션에서는 이러한 각 기술을 높은 수준에서 소개합니다.  

## Nondeterministic (Random) Wallets
첫 번째 이더 리움 지갑 (이더 리움 사전 판매용으로 제작 됨)에서 각 지갑 파일은 임의로 생성 된 단일 개인 키를 저장한다.   
이러한 "구식"지갑은 여러면에서 열등하기 때문에 이러한 지갑은 결정적 지갑으로 대체된다.  
예를 들어, 이더 리움을 사용하는 동안 개인정보를 강화하기 위해 이더 리움 주소 재사용을 피하는 것이 좋다.   
즉, 자금을받을 때마다 새 주소 (새 개인 키가 필요함)를 사용하는 것입니다.   
토큰을 많이 처리하면 비용이 많이들고 각 거래에 대해 새 주소를 사용할 수 있다.   
이 관행을 따르려면 비 결정적 지갑이 정기적으로 키 목록을 늘려야하므로 정기적으로 백업한다. 지갑을 백업하기 전에 데이터를 분실하면 자금 및 스마트 계약에 대한 액세스 권한을 잃게됩니다.  
"유형 0"비 결정적 지갑은 "적시"방식으로 모든 새 주소에 대해 새 지갑 파일을 생성하기 때문에 처리하기 가장 어렵다.  
그럼에도 불구하고 많은 Ethereum 클라이언트 (geth 포함) 는 추가 보안을 위해 암호로 암호화 된 단일 (임의로 생성 된) 개인 키를 포함하는 JSON 인코딩 파일 인 키 저장소 파일을 사용합니다.    
다음은JSON 파일의 내용이다.  
```
{
    "address": "001d3f1ef827552ae1114027bd3ecf1f086ba0f9",
    "crypto": {
        "cipher": "aes-128-ctr",
        "ciphertext":
            "233a9f4d236ed0c13394b504b6da5df02587c8bf1ad8946f6f2b58f055507ece",
        "cipherparams": {
            "iv": "d10c6ec5bae81b6cb9144de81037fa15"
        },
        "kdf": "scrypt",
        "kdfparams": {
            "dklen": 32,
            "n": 262144,
            "p": 1,
            "r": 8,
            "salt":
                "99d37a47c7c9429c66976f643f386a61b78b97f3246adca89abe4245d2788407"
        },
        "mac": "594c8df1c8ee0ded8255a50caf07e8c12061fd859f4b7c76ab704b17c957e842"
    },
    "id": "4fcb2ba4-ccdb-424f-89d5-26cce304bf9c",
    "version": 3
}
```

키스토어 형식은 식은 무차별 대입, 사전 및 레인보우 테이블 공격으로부터 보호하는 암호 확장 알고리즘이라고도 하는 키 파생 함수 (KDF)를 사용한다.  
개인키는 암호문구로 직접 암호화 되지 않는다.   
대신 반복적으로 해싱하여 암호를 확장한다.   
해싱 함수는 262,144 라운드 동안 반복되며 키 저장소 JSON에서 crypto.kdfparams.n 매개 변수로 볼 수 있다.   
암호를 무차별 대입하려는 공격자는 시도 된 모든 암호에 대해 262,144 라운드의 해싱을 적용해야하므로 공격 속도가 충분히 느려져 충분히 복잡하고 길이가 긴 암호를 사용할 수 없게 만든다.  
자바스크립트 라이브러리 keythereum과 같이 키 저장소 형식을 읽고 쓸 수 있는 소프트웨어 라이브러리가 많이 있다.  
|  |  |  
|--|--|  
|팁|비결정론적 지갑의 사용은 단순한 시험 이외의 어떤 것에도 금물이다. 가장 기본적인 상황 외에는 어떤 것도 백업하고 사용하기에는 너무 번거롭다. 대신 백업에 니모닉 시드가 있는 업계 표준 기반 HD 지갑을 사용하십시오.|  

## Deterministic (Seeded) Wallets
결정적 또는 "시드"지갑은 단일 마스터 키 또는 시드에서 모두 파생 된 개인 키를 포함하는 지갑입니다.   
시드는 인덱스 번호 또는 "체인 코드"( 확장 공개 및 개인 키 참조)와 같은 다른 데이터와 결합되어 임의의 수의 개인 키를 도출한다.  
결정 론적 지갑에서 시드는 모든 파생 키를 복구하기에 충분하므로 생성시 단일 백업으로 지갑의 모든 자금과 스마트 계약을 보호하는 데 충분하다.   
시드는 지갑 내보내기 또는 가져 오기에도 충분하므로 서로 다른 지갑 구현간에 모든 키를 쉽게 마이그레이션 할 수 있다.
이 디자인은 전체 지갑에 대한 액세스 권한을 얻기 위해 시드 만 필요하기 때문에 시드의 보안을 가장 중요하게 만든다.   
반면에 단일 데이터에 보안 노력을 집중할 수 있다는 것은 장점으로 볼 수 있다.  


## Hierarchical Deterministic Wallets (BIP-32/BIP-44)
결정 론적 지갑은 단일 시드에서 많은 키를 쉽게 추출 할 수 있도록 개발되었다.   
현재 결정론적 지갑의 가장 진보된 형태는 비트코인의 BIP-32 표준에 의해 정의된 계층적 결정론적(HD) 지갑이다.   
HD 지갑에는 트리 구조에서 파생 된 키가 포함되어있어 부모 키가 일련의 자식 키를 파생 할 수 있으며, 각 자식 키는 일련의 손자 키 등을 파생 할 수 있습니다.   
이 트리 구조는 단일 시드에서 생성 된 키 트리 인 HD 지갑에 설명되어 있다.  
![figure 1](https://github.com/ethereumbook/ethereumbook/raw/develop/images/hd_wallet.png)  
HD 지갑은 단순한 결정론적 지갑보다 몇 가지 중요한 이점을 제공한다.   
첫째, 트리 구조는 특정 서브키 분기를 사용하여 지불을 받고 다른 분기를 사용하여 발신 대금과의 변경을 받는 경우 등 추가적인 조직적 의미를 표현하는데 사용될 수 있다.   
키의 지점은 부서, 자회사, 특정 기능 또는 회계 범주에 서로 다른 지점을 할당하는 기업 환경에서도 사용될 수 있다.  
HD 지갑의 두 번째 장점은 사용자가 해당 개인 키에 접근하지 않고도 일련의 공개 키를 만들 수 있다는 것이다.    
이를 통해 HD 지갑을 안전하지 않은 서버나 시계 전용 또는 수신 전용 용량에서 사용할 수 있으며, 지갑에는 자금을 사용할 수 있는 개인 키가 없다.  

## Seeds and Mnemonic Codes (BIP-39)
안전한 백업 및 검색을 위해 개인 키를 인코딩하는 방법은 여러 가지가 있다.   
현재 선호되는 방법은 올바른 순서로 조합할 때 개인 키를 고유하게 재생성할 수 있는 일련의 단어를 사용하는 것이다.   
이것은 니모닉으로 알려져 있으며, 접근방식은 BIP-39에 의해 표준화되었다.   
오늘날 많은 이더리움 지갑(기타 암호화폐용 지갑은 물론)이 이 표준을 사용하고 있으며, 상호운용 가능한 니모닉을 이용한 백업 및 복구를 위해 시드를 가져오고 내부낼 수 있다.  
이러한 접근 방식이 보편화된 이유를 알아보려면 다음 예를 살펴보도록 하자.  

A seed for a deterministic wallet, in hex  
```
FCCF1AB3329FD5DA3DA9577511F8F137
```
A seed for a deterministic wallet, from a 12-word mnemonic  
```
wolf juice proud gown wool unfair
wall cliff insect more detail hub
```
실제로, 16진법을 쓸 때 오류가 발생할 확률은 높다. 이와는 대조적으로 알려진 단어 목록은 주로 단어(특히 영어 단어)의 작성에서 중복성이 높기 때문에 다루기가 상당히 쉽다.   
만약 "inzect"가 우연히 기록되었다면, 지갑 복구가 필요할 때, "inzect"는 유효한 영어 단어가 아니며 "insect"를 대신 사용해야 한다는 것을 빠르게 결정할 수 있다.   
HD 지갑을 관리할 때 좋은 관행이기 때문에 시드의 표현을 기록하는 것에 대해 이야기하고 있다.  
즉, 데이터 손실(사고든 도난이든)의 경우 시드가 지갑을 복구하기 위해 필요하기 때문에 백업이 매우 중요하다.   
그러나 시드는 극도로 비공개로 유지해야 하므로 디지털 백업은 주의 깊게 피해야 한다.   
따라서 펜과 종이를 사용하여 백업하라는 조언이 있다.  
요약하자면, 복구 단어 목록을 사용하여 HD 지갑의 시드를 인코딩하는 것은 안전하게 내보내고, 변환하고, 종이에 기록하고, 오류 없이 읽고, 개인 키 세트를 다른 지갑으로 가져오는 가장 쉬운 방법이 된다.  

# Wallet Best Practices
암호화폐 지갑 기술이 발전하면서 지갑을 폭넓게 상호운용하고, 사용하기 쉽고, 안전하고, 유연하게 만드는 특정 공통 산업 표준이 등장했다.   
또한 이러한 표준은 지갑이 하나의 니모닉에서 복수의 서로 다른 암호화폐에 대한 키를 추출할 수 있도록 한다.  
이러한 일반적인 표준은 다음과 같다.  

•	BIP-39 기반 니모닉 코드 단어
•	BIP-32 기반 HD 지갑
•	BIP-43 기반 다목적 HD 지갑 구조
•	BIP-44 기반 다중 통화성 및 다중 계정 지갑

이러한 표준은 향후 개발로 인해 변경되거나 폐기될 수 있지만, 현재로서는 대부분의 블록체인 플랫폼과 그 가상화폐에 대한 사실상의 지갑 표준이 된 연동 기술을 형성하고 있다.  
표준은 광범위한 소프트웨어와 하드웨어 지갑에 의해 채택되어 이 모든 지갑들이 상호운용 가능하게 되었다.   
사용자는 이들 지갑 중 하나에서 생성된 니모닉을 내보내 다른 지갑으로 가져와 모든 키와 주소를 복구할 수 있다.  
이러한 표준을 지원하는 소프트웨어 지갑의 예로는 Jaxx, MetaMask, MyCrypto 및 MyEtherWallet (MEW) 등이 있다.   
이러한 표준을 지원하는 하드웨어 지갑의 예로는 Keepkey, Ledger 및 Trezor등이 있다.  
다음 절에서는 이러한 각 기술을 자세히 검토한다.  
|  |  |  
|--|--|  
|팁|이더리움 월렛을 구현하는 경우 다음 절에서 설명한 BIP-32, BIP-39, BIP-43 및 BIP-44 표준에 따라 백업을 위한 니모닉 코드로 인코딩된 시드가 있는 HD 지갑으로 제작되어야 한다.|  

## Mnemonic Code Words (BIP-39)
니모닉 코드 단어는 결정 론적 지갑을 유도하기 위해 시드로 사용되는 난수를 인코딩하는 단어 시퀀스이다.  
단어의 순서는 시드를 다시 생성하기에 충분하며 거기에서 지갑과 모든 파생 키를 다시 생성한다.   
니모닉 단어로 결정 론적 지갑을 구현하는 지갑 애플리케이션은 지갑을 처음 만들 때 사용자에게 12 ~ 24 개의 단어 시퀀스를 보여준다.   
이 단어의 순서는 지갑 백업이며 동일하거나 호환 가능한 지갑 응용 프로그램에서 모든 키를 복구하고 다시 만드는 데 사용할 수 있다.   
앞서 설명했듯이 니모닉 단어 목록을 사용하면 쉽게 읽고 정확하게 기록 할 수 있기 때문에 사용자가 지갑을 더 쉽게 백업 할 수 있습니다.  
|  |  |  
|--|--|  
|노트|니모닉 단어는 종종 "두뇌 지갑"과 혼동된다. 그들은 같지 않다. 큰 차이점은 브레인 월렛은 사용자가 선택한 단어로 구성되는 반면, 니모닉 단어는 지갑에서 무작위로 생성되어 사용자에게 제공된다는 것이다. 이 중요한 차이점은 인간이 무작위성의 매우 열악한 원천이기 때문에 니모닉 단어를 훨씬 더 안전하게 만든다. 아마도 더 중요한 것은 "brainwallet"이라는 용어를 사용하는 것은 단어를 외워야한다는 것을 암시하는 것이다. 이는 끔찍한 생각이며 필요할 때 백업을하지 않는 방법이다|  

니모닉 코드는 BIP-39에 정의되어 있다. BIP-39는 니모닉 코드 표준의 구현 중 하나라는 점에 유의한다.  
Electrum Bitcoin 지갑에서 사용하고 BIP-39 이전에 사용되는 단어 집합이  다른 표준이  있다.  
BIP-39는 Trezor 하드웨어 지갑 뒤에 있는 회사에서 제안한 것으로 Electrum의 구현과 호환되지 않는다.   
그러나 BIP-39는 이제 상호운용 가능한 수십 개의 구현에 걸쳐 광범위한 업계 지원을 달성했으며, 사실상의 산업 표준으로 간주되어야 한다.   
또한 BIP-39는 Ethereum을 지원하는 다중 통화 지갑을 생성하는 데 사용할 수 있지만 Electrum seed는 사용할 수 없습니다.  
BIP-39는 니모닉 코드 및 시드 생성을 정의하며 9단계로 설명한다.   
명확성을 위해 프로세스는 두 부분으로 나뉜다: 1단계부터 6단계까지는 니모닉 단어 생성에 표시되고 7단계부터 9단계까지는 니모닉에서 시드까지 표시된다.  

## Generating mnemonic words
니모닉 단어는 BIP-39에 정의 된 표준화 된 프로세스를 사용하여 지갑에서 자동으로 생성된다.   
지갑은 엔트로피 소스에서 시작하여 체크섬을 추가 한 다음 엔트로피를 단어 목록에 매핑한다.  

1.	128~256비트의 암호화된 무작위 시퀀스 S를 생성한다.  
2.	S의 SHA-256 해시의 첫 번째 길이 ÷ 32비트를 취하여 S의 체크섬을 생성한다.  
3.	랜덤 시퀀스 S의 끝에 체크섬을 추가한다.  
4.	시퀀스 앤 체크섬 결합을 11비트의 섹션으로 나누십시오.  
5.	각 11비트 값을 사전 정의된 사전 2,048단어의 단어에 매핑하십시오.  
6.	순서가 유지되는 단어의 순서에서 니모닉 코드를 만드십시오  

[Mnemonic codes: entropy and word length]
| Entropy  (bits) | Checksum  (bits) | Entropy + checksum  (bits) | Mnemonic length  (word) |    
|---|---|---|--|  
| 128 | 4 | 132 | 12 |    
| 160 | 5 | 165 | 15 |  
| 192 | 6 | 198 | 18 |  
| 224 | 7 | 231 | 21 |  
| 256 | 8 | 264 | 24 |  

![이미지1](https://github.com/ethereumbook/ethereumbook/raw/develop/images/bip39-part1.png)

![이미지2](https://github.com/ethereumbook/ethereumbook/raw/develop/images/bip39-part2.png)  

엔트로피를 생성하고 니모닉 단어로 인코딩하면 엔트로피가 니모닉 단어를 생성하는 데 사용되는 방법을 보여준다.  

니모닉 코드 : 엔트로피 및 단어 길이 는 엔트로피 데이터의 크기 와 단어 단위의 니모닉 코드 길이 간의 관계를 보여줍니다.  

## From mnemonic to seed
니모닉 단어는 128 ~ 256 비트 길이의 엔트로피를 나타낸다.   
그런 다음 엔트로피는 키 확장 기능 PBKDF2를 사용하여 더 긴 (512 비트) 시드를 유도하는 데 사용된다.   
생성 된 시드는 결정 론적 지갑을 구축하고 키를 파생하는 데 사용된다.  
키 스트레치 기능은 니모닉과 솔트 의 두 가지 매개 변수를 사용합니다  
키 확장 기능에서 솔트의 목적은 무차별 대입 공격을 가능하게하는 조회 테이블을 구축하기 어렵게 만드는 것입니다.   
BIP-39 표준에서 솔트는 또 다른 목적을 가지고 있습니다.  
그것은 우리가 BIP-39의 선택적 암호에서 더 자세히 설명하듯이 시드를 보호하는 추가적인 보안 요소 역할을 하는 암호의 도입을 허용한다.  

7 단계부터 9 단계까지 설명 된 프로세스는 이전 섹션에서 설명 된 프로세스에서 계속됩니다.

7.	PBKDF2 키 스텐칭 기능의 첫 번째 파라미터는 6단계에서 생성된 니모닉이다.  
8.	PBKDF2 키 스텐칭 기능의 두 번째 파라미터는 salt이다. Salt는 사용자가 제공한 암호문구(옵션)와 연결된 문자열 상수 "메모닉"으로 구성된다.  
9.	PBKDF2는 HMAC-SHA512 알고리즘으로 해싱 2,048라운드를 사용하여 니모닉 및 salt 파라미터를 확장하여 최종 출력으로 512비트 값을 생성한다. 저 512비트 값이 시드이다.  
|  |  |  
|--|--|  
|노트|2,048 라운드의 해싱이 포함 된 키 확장 기능은 니모닉이나 암호에 대한 무차별 대입 공격에 대해 다소 효과적인 보호인다. 몇 천 개 이상의 암호와 니모닉 조합을 시도하면 비용이 많이 드는 반면, 가능한 파생된 시드의 수는 방대하다.|  

## Optional passphrase in BIP-39
BIP-39 표준은 시드 파생에 선택적 암호를 사용할 수 있도록한다.  
암호를 사용하지 않으면 니모닉이 상수 문자열 "니모닉"으로 구성된 솔트로 확장되어 주어진 니모닉에서 특정 512 비트 시드를 생성합니다.   
암호를 사용하는 경우 스트레칭 기능은 동일한 니모닉에서 다른 시드를 생성한다 .  
실제로 단일 니모닉이 주어지면 가능한 모든 암호가 다른 시드로 연결된다.  
기본적으로 "잘못된"암호는 없다.   
모든 암호문은 유효하며 모두 다른 시드로 이어 져서 가능한 방대한 초기화되지 않은 지갑을 형성한다.   
가능한 지갑 세트가 너무 커서 (2 512) 암호문의 복잡성과 길이가 충분하다면 사용중인 것을 무차별 대입하거나 우연히 추측 할 가능성이 없다.  
|  |  |  
|--|--|  
|팁|BIP-39에는 "잘못된" 암호문이 없다. 모든 암호는 어떤 지갑으로 연결되는데, 이전에 사용하지 않는 한 지갑은 비어 있을 것이다|  

선택적 암호문구는 두 가지 중요한 기능을 생성한다.  
•	니모닉을 스스로 쓸모 없게 만드는 두번째요소는 니모닉 백업을 도둑으로부터 보호한다  
•	그럴듯한 거부 성 또는 "협박 지갑"의 한 형태로, 선택한 암호가 적은 양의 자금이있는 지갑으로 연결되며, 대부분의 자금이 포함 된 "실제"지갑에서 공격자를주의를 분산시키는 데 사용된다.
암호의 사용은 다음과 같은 손실 위험도 초래한다는 점에 유의해야 한다.
•	만약 지갑 소유자가 무능력하거나 죽어서 아무도 그 암호를 알지 못한다면, 시드는 쓸모없고 지갑에 저장된 모든 자금은 영원히 없어진다.
•	반대로 주인이 시드와 같은 장소에서 암호를 백업하면 두번째요소의 목적이 사라진다.

암호는 매우 유용하지만, 소유자가 생존한 상속인이 가상화폐를 회수할 수 있는 가능성을 고려하여 신중하게 계획된 백업 및 복구 프로세스와 결합하여 사용해야 한다.  

## Working with mnemonic codes
BIP-39는 다양한 프로그래밍 언어의 라이브러리로 구현된다.  

python-mnemonic  
Python으로 BIP-39를 제안한 SatoshiLabs 팀의 표준 참조 구현  

ConsenSys/eth-lightwallet  
노드 및 브라우저 용 경량 JS 이더 리움 지갑 (BIP-39 포함)  

npm/bip39  
비트 코인 BIP-39의 JavaScript 구현 : 결정 론적 키 생성을위한 니모닉 코드  

독립형 웹 페이지 (독립형 웹 페이지로서의 BIP-39 생성기)에 구현 된 BIP-39 생성기도 있는데 , 이는 테스트 및 실험에 매우 유용합니다.  
니모닉 코드 변환기는 니모닉, 시드, 그리고 확장 된 개인 키를 생성합니다.   
브라우저에서 오프라인으로 사용하거나 온라인으로 액세스 할 수 있다.  
![figure 4](https://github.com/ethereumbook/ethereumbook/raw/develop/images/bip39_web.png)  


## Creating an HD Wallet from the Seed
HD 지갑은 128비트, 256비트 또는 512비트 무작위 번호인 단일 루트 시드로 생성된다.  
가장 일반적으로 이 씨앗은 앞의 절에서 자세히 설명한 니모닉에서 생성된다.  
HD 지갑의 모든 키는 이 루트 시드에서 결정적으로 파생되어, 어떤 호환되는 HD 지갑에서도 그 시드의 전체 HD 지갑을 다시 만들수 있다.   
이를 통해 루트 시드가 파생된 니모닉만 전송하면 수천, 심지어 수백만 개의 키가 들어 있는 HD 지갑을 쉽게 내보내고, 백업, 복원 및 가져올 수 있다.  


## HD Wallets (BIP-32) and Paths (BIP-43/44)
대부분의 HD 지갑은 BIP-32 표준을 따르며, 이는 결정론적 키 생성을 위한 사실상의 산업 표준이 되었다.  
여기서 BIP-32의 모든 세부 사항을 논의하지는 않고, 지갑에서 어떻게 사용되는지를 이해하는 데 필요한 구성요소만 설명한다.   
주요 중요한 측면은 HD 지갑에서 볼 수 있듯이 파생 된 키가 가질 수있는 트리와 같은 계층 적 관계다.   
확장 키와 강화 키의 아이디어를 이해하는 것도 중요하며, 이는 다음 절에서 설명된다.  
많은 소프트웨어 라이브러리에서 제공되는 수십 개의 상호 운용 가능한 BIP-32 구현이 있다.  
이들은 대부분 비트코인 지갑용으로 설계돼 다른 방식으로 주소를 구현하지만 이더리움의 BIP-32 호환 지갑과 동일한 키 디리버레이션 구현을 공유한다.   
이더리움용으로 설계된 것을 사용하거나, 이더리움 어드레스 인코딩 라이브러리를 추가하여 비트코인에서 변형시키십시오.  
 BIP-32테스트 및 실험하는데 매우 유용한 독립형 웹페이지로 구현된 BIP-32 생성기도 있다  
|  |  |  
|--|--|  
|경고|독립형 BIP-32 생성는 HTTPS 사이트가 아니다. 그것은 이 도구의 사용이 안전하지 않다는 것을 상기시키기 위한 것이다. 그것은 단지 시험용이다. 이 사이트에서 생성한 키를 실제 자금으로 사용해서는 안 된다|  


## Extended public and private keys
BIP-32 용어에서 키는 "확장"될 수 있습니다.   
올바른 수학 연산을 통해 이러한 확장 된 "상위"키를 사용하여 "하위"키를 파생 할 수 있으므로 앞에서 설명한 키와 주소의 계층 구조를 생성 할 수 있다.   
상위 키는 트리의 맨 위에있을 필요가 없다. 트리 계층의 어느 곳에서나 선택할 수 있다.   
키를 확장하려면 키 자체를 가져와 여기에 특수 체인 코드 를 추가하는 작업이 포함된다 .   
체인 코드는 하위 키를 생성하기 위해 각 키와 혼합되는 256 비트 이진 문자열입니다.  

키가 개인 키이면 접두사 xprv로 구분되는 확장 개인 키가 됩니다 .  
```
xprv9s21ZrQH143K2JF8RafpqtKiTbsbaxEeUaMnNHsm5o6wCW3z8ySyH4UxFVSfZ8n7ESu7fgir8i 
```
확장 공개 키는 접두사 XPUB에 의해 구별된다 :
```
xpub661MyMwAqRbcEnKbXcCqD2GT1di5zQxVqoHPAgHNe8dv5JP8gWmDproS6kFHJnLZd23tWevhdn ...
```
HD 지갑의 매우 유용한 특성은 개인 키 없이 부모 공개 키에서 자식 공개 키를 추출 할 수 있다는 것 이다.   
이를 통해 하위 공개 키를 파생하는 두 가지 방법이 있다.   
하위 개인 키에서 직접 또는 상위 공개 키에서.  
따라서 확장 된 공개 키를 사용하여 HD 지갑 구조의 해당 분기에있는 모든 공개 키 (및 공개 키만)를 도출 할 수 있다.  
이 단축키는 서버 또는 애플리케이션이 확장 된 공개 키의 복사본이 있지만 개인 키는 전혀없는 매우 안전한 공개 키 전용 배포를 만드는 데 사용할 수 있다. 이러한 종류의 배포는 무한한 수의 공개 키와 이더 리움 주소를 생성 할 수 있지만 해당 주소로 보낸 돈을 쓸 수는 없다.   
한편, 더 안전한 다른 서버에서 확장 된 개인 키는 거래에 서명하고 돈을 지출하기 위해 해당하는 모든 개인 키를 파생 할 수 있습니다.  
이 방법의 일반적인 응용 프로그램 중 하나는 전자 상거래 응용 프로그램을 제공하는 웹 서버에 확장 공개 키를 설치하는 것이다.   
웹 서버는 공개 키 파생 기능을 사용하여 모든 거래 (예 : 고객 쇼핑 카트)에 대해 새로운 이더 리움 주소를 생성 할 수 있으며 도난에 취약한 개인 키를 갖지 않는다.   
  HD 지갑이 없으면 이를 수행하는 유일한 방법은 별도의 보안 서버에서 수천 개의 이더 리움 주소를 생성 한 다음 전자 상거래 서버에 미리 로드하는 밥법밖에 없다. 이 접근 방식은 번거롭고 서버에 키가 부족하지 않도록 지속적인 유지 관리가 필요하므로 HD 지갑에서 확장 된 공개 키를 사용하는 것이 선호한다.  
이 솔루션의 또 다른 일반적인 응용 분야는 콜드 스토리지 또는 하드웨어 지갑이다.  
이 시나리오에서 확장 된 개인 키는 하드웨어 지갑에 저장 될 수 있고 확장 된 공개 키는 온라인으로 유지 될 수 있습니다.   
사용자는 "수신"주소를 마음대로 만들 수 있으며 개인 키는 오프라인으로 안전하게 저장됩니다.   
자금을 사용하기 위해 사용자는 오프라인 서명 이더 리움 클라이언트에서 확장 된 개인 키를 사용하거나 하드웨어 지갑 장치에서 트랜잭션에 서명 할 수 있다.  


## Hardened child key derivation
확장된 공개 키, 즉 xpub에서 공개 키의 분기를 도출하는 능력은 매우 유용하지만 잠재적인 위험을 수반한다. xpub에 대한 액세스는 하위 개인 키에 대한 액세스를 제공하지 않는다.   
그러나 xpub에는 체인 코드(부모 공용 키에서 하위 공용 키를 추출하는 데 사용됨)가 포함되어 있기 때문에, 만일 하위 개인 키가 알려졌거나, 또는 어떻게든 누출된 경우, 다른 모든 하위 개인 키를 추출하는 데 체인 코드와 함께 사용할 수 있다.  
유출된 아동 개인 키 한 개와 부모 체인 코드는 모든 자식들의 개인 키를 공개한다.  
더 나쁜 것은 부모 체인 코드와 함께 자식 개인 키를 사용하여 부모 개인 키를 추론할 수 있다.  
이러한 위험에 대처하기 위해 HD 지갑은 강화 된 파생이라는 대체 파생 기능을 사용하며, 이는 부모 공용 키와 자식 체인 코드 사이의 관계를 "차단"한다.   
강화된 파생 함수는 부모 공개 키 대신 부모 개인 키를 사용하여 자식 체인 코드를 도출한다. 이렇게 하면 부모/자식 시퀀스에 "방화벽"이 생성되며, 부모 또는 형제 개인 키를 손상시키는 데 사용할 수 없는 체인 코드가 생성된다.  
간단히 말해서, xpub의 편리함을 이용하여 누출된 체인 코드의 위험에 노출되지 않고 공용 키의 가지를 유도하고 싶다면, 정상적인 부모보다는 강화된 부모로부터 유도해야 한다.   
마스터 키의 레벨 1 하위 키가 항상 강화된 파생에 의해 파생되도록 하여 마스터 키의 손상을 방지하는 것이 모범 사례다  

## Index numbers for normal and hardened derivation
주어진 부모 키에서 하나 이상의 자식 키를 추출할 수 있는 것은 분명히 바람직하다.   
이를 관리하기 위해 인덱스 번호가 사용된다.   
각 인덱스 번호는 특수 하위 파생 함수을 사용하여 상위 키와 결합할 때 다른 하위 키를 제공한다.  
BIP-32 상위-하위간 파생함수에 사용되는 인덱스 번호는 32비트 정수다.   
일반(강화되지 않은) 파생 함수를 통해 도출된 키와 강화 추출을 통해 도출된 키를 쉽게 구분하기 위해 이 지수 번호는 두 범위로 나뉜다.   
0 ~ 2 31 –1 (0x0 ~ 0x7FFFFFFF) 사이의 인덱스 번호는 일반 파생 에만 사용 된다 .   
2 31 ~ 2 32 –1 (0x80000000 ~ 0xFFFFFFFF) 사이의 인덱스 번호 만 사용 된다.  
강화 된 파생을 위해. 따라서 인덱스 번호가 2 31 보다 작 으면 자식이 정상이고 인덱스 번호가 2 31 이상 이면 자식이 강화된다.  
인덱스 번호를 읽고 표시하기 쉽게 하기 위해 강화 하위항목의 인덱스 번호는 0부터 시작하지만 기본 기호와 함께 표시된다. 따라서 첫 번째 정상 하위 키는 0으로 표시되는 반면 첫 번째 강화된 하위 키  (인덱스 0x80000000)는 0 # x27;로 표시된다.   
그러면 두 번째 강화 키의 인덱스는 0x80000001이고 1 & # x27;로 표시된다. HD 지갑 인덱스 i & # x27;를 보면 2 31 + i 를 의미 한다.  

## HD wallet key identifier (path)
HD 지갑의 키는 "경로" 명명 규칙을 사용하여 식별되며, 트리의 각 레벨은 슬래시(/) 문자로 구분된다(HD 지갑 경로 예 참조).   
마스터 개인 키에서 파생 된 개인 키는 m으로 시작한다. 마스터 공개 키에서 파생 된 공개 키는 M으로 시작한다.   
따라서 마스터 개인 키의 첫 번째 하위 개인 키는 m / 0입니다.   
첫 번째 자식 공개 키는 M / 0이다. 첫 번째 자식의 두 번째 손자는 m / 0 / 1이다.  
키의 "고정"은 파생 된 마스터 키에 도달 할 때까지 오른쪽에서 왼쪽으로 읽는다.   
예를 들어, 식별자 m / x / y / z는 키 m / x / y의 z 번째 자식 인 키를 설명한다.   
즉, 키 m / x의 y 번째 자식 인 키는 다음의 x 번째 자식이다.  

## Navigating the HD wallet tree structure
HD 지갑 트리 구조는 엄청나게 유연하다.   
이것의 다른 측면은 무한한 복잡성을 허용한다는 것이다: 각 부모 확장 키에는 40억 명의 하위가 있을 수 있다: 20억 명의 일반 자식과 20억 명의 강화 자식.   
그 자식들은 각각 40억 명의 자식들을 가질 수 있고, 기타 등등.   
트리는 여러분이 원하는 만큼 깊을 수 있고 잠재적으로 무한한 수의 세대를 가질 수 있다.     
그 모든 가능성 때문에, 이 아주 큰 트리들을 탐색하는 것은 꽤 어려워질 수 있다.  
두 개의 BIP는 HD 지갑 트리의 구조에 대한 표준을 만들어 잠재적인 복잡성을 관리하는 방법을 제공한다.    
BIP-43은 트리 구조의 "목적"을 나타내는 특수 식별자로 첫 번째 강화된 자식의 인덱스를 사용할 것을 제안한다. BIP-43에 근거하여 HD 지갑은 트리의 레벨 1 분기 하나만 사용해야 하며, 인덱스 번호는 트리의 나머지 구조와 네임스페이스를 식별하여 지갑의 목적을 정의해야 한다.   
좀 더 구체적으로, 지점 m/i&#x27;/만 사용하는 HD 지갑. 특정 목적을 나타내기 위한 것이며 그 목적은 인덱스 번호 i로 식별된다.  
이 규격을 확장하면서, BIP-44는 "목적" 번호를 44'로 설정함으로써 의미하는 다중 통화성 다중 계정 구조를 제안한다.   
BIP-44 구조에 따른 모든 HD 지갑은 트리의 한 가지 가지(m/44'/*)만 사용한다는 사실로 확인된다.  
BIP-44는 구조물을 다음과 같은 5가지 미리 정의된 트리 레벨로 구성하도록 지정한다.  
m / purpose' / coin_type' / account' / change / address_index
첫 번째 단계인 목적&#x27;은 항상 44&#x27;로 설정된다.   
2단계인 코인_type&#x27;은 가상화폐 코인의 종류를 명시해 각 통화마다 2단계 이하 자체 하위 계수가 있는 다중통화 HD 지갑이 허용된다. SLIP0044 라는 표준 문서에 정의 된 여러 통화가 있습니다 예로, Ethereum is m/44&#x27;/60&#x27;, Ethereum Classic is m/44&#x27;/61&#x27;, Bitcoin is m/44&#x27;/0&#x27;, and Testnet for all currencies is m/44&#x27;/1&#x27;.
트리의 3단계는 계정&#x27;으로, 사용자는 자신의 지갑을 회계나 조직 목적을 위해 별도의 논리적 하위 계정으로 세분화할 수 있다. 예를 들어 HD 지갑에는 m/44&#x27;/60&#x27;/0&#x27; 및 m/44&#x27;/60&#x27;/1&#x27;의 두 가지 이더리움 "계정"이 포함될 수 있다.   
각 계정은 자체 하위 트리의 루트다.  
BIP-44는 원래 비트코인을 위해 만들어졌기 때문에 이더리움 세계와는 관련이 없는 '특이한'부분이 포함되어 있다.   
경로의 4단계인 change의 네 번째 단계에서 HD 지갑은 수신 주소 작성용과 변경 주소 작성용 두 개의 하위 트리를 가진다.   
비트코인처럼 주소를 변경할 필요가 없어 이더리움에는 '수신' 경로만 사용된다.   
  
  이전 레벨은 경화된 파생을 사용했지만, 이 레벨은 정상적인 파생을 사용한다는 점에 유의하십시오. 트리의 계정 레벨이 보안되지 않은 환경에서 사용하기 위해 확장된 공용 키를 내보낼 수 있도록 하기 위함입니다. 사용 가능한 주소는 HD 지갑이 4단계 아동으로 파생하여 트리의 5단계는 address_index가 된다.   
예를 들어, 1차 계정에서 이더리움 결제를 위한 세 번째 수취 주소는 M/44&#x27;/60&#x27;/0&#x27;/0/2일 것이다.   


# Conclusion
지갑은 모든 사용자 대면 블록 체인 애플리케이션의 기초입니다.   
이를 통해 사용자는 키 및 주소 모음을 관리 할 수 있습니다.   
또한 지갑을 사용하면 [tx_chapter] 에서 볼 수 있듯이 디지털 서명을 적용하여 사용자가 이더 의 소유권을 입증하고 거래를 승인 할 수 있습니다.  
