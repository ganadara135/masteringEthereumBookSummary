# Wallets
지갑의 의미가 다양함  
상위 개념에선 이더리움과 주 사용자 인터페이스로서 소프트웨어 애플리케이션이다  
범위를 좁혀서 개발자 관점에선 사용자 키를 관리하는 프로그램임  
본 챕터에서는 개발자 관점에서만 다룬다  

지갑은 이더리움에서 몇가지 다른 것을 설명 한다.  
높은 수준에서 지갑은 이더리움의 기본 사용자 인터페이스 역할을 하는 소프트웨어 애플리케이션이다.  
지갑은 사용자의 돈에 대한 액세스, 키 및 주소 관리, 잔액 추적, 트랜잭션 생성 및 서명을 제어한다.  
또 일부 이더리움 지갑은 ERC20 토큰과 같은 계약과도 상호작용할 수 있다.  
좁게 보면 개발자 관점에서, 지갑은 사용자의 키를 저장하고 관리하는 데 사용되는 시스템을 가리킨다.  
모든 지갑에는 키를 관리하는 구성 요소가 있다. 일부 지갑은 그게 전부이다. 다른 지갑은 훨씬 더 광범위한 범주의 일부입니다. 브라우저 는 이더리움 기반 분산 애플리케이션에 대한 인터페이스 인 DApp 또는 분산형 애플리케이션챕터 에서 자세히 살펴볼 것.  
지갑이라는 용어로 합쳐진 다양한 카테고리 사이에는 명확한 구분선이 없다.   
이 챕터에서는 개인 키의 컨테이너와 이러한 키를 관리하기 위한 시스템으로 지갑을 살펴보기로 한다.  

# Wallet Technology Overview
이 섹션에서는 사용자 친화적이고, 안전하고, 유연한 이더리움 지갑을 만드는 데 사용되는 다양한 기술을 요약한다.  
지갑을 설계할 때 고려해야할 중요사항은 편의성과 개인 정보 보호 사이의 균형 이다.  
가장 편리한 이더리움 지갑은 모든걸 재사용 할 수 있는 개인 키와 주소가 있는 지갑 이다.  
이런 솔루션은 쉽게 모든 거래를 추적하고 연관시킬 수 있기 때문에 개인정보에 취약하다.  
모든 거래에 새로운 키를 사용하는 것이 개인정보보호를 위해 가장 좋지만 관리하기가 어렵다.  
올바른 균현을 이루기는 어렵지만 좋은 지갑 설계가 중요한 이유임.  
이더리움에 대한 일반적 오해는 이더리움 지갑에 이더나 토큰이 들어 있다는 것이다.   엄밀히 말하면, 지갑에는 열쇠만 있다. 이더 또는 다른 토큰이 이더리움 블록체인에 기록된다.  
사용자는 지갑에 있는 키로 트랜잭션에 서명하여 네트워크에서 토큰을 제어한다.  
어떤 의미에서 이더리움지갑은 키체인이다. 지갑이 보유한 키가 이더 나 토큰을 다른 사람에게 전송하는 데 필요한 유일한 것임을 감안할 때 실제로 이러한 구분은 무관하다.   
차이가 중요한 부분은 기존 은행의 중앙 집중식 시스템 (본인과 은행 만이 계좌에있는 돈을 볼 수 있고 거래를 하려고 자금 이동하기위해 은행에 요청)에서 사고 방식을 바꾸는 것입니다.  
블록 체인 플랫폼의 탈 중앙화 시스템 (모든 사람이 계정의 이더 잔고를 볼 수 있지만 계정 소유자를 모르고 모든 사람이 소유자가 거래를 위해 자금을 제정).   
실제로 이것은 지갑이 필요 없이 계좌를 확인할 수 있는 독립적인 방법이 있다는 것을 의미한다.   
게다가, 만약 당신이 사용하기 시작한 지갑 앱이 싫어진다면, 당신은 당신의 계정 처리를 현재의 지갑에서 다른 지갑으로 옮길 수 있다.  
노트	이더 리움 지갑은 이더 나 토큰이 아닌 키가 있다. 지갑은 개인 키와 공개 키 쌍을 포함하는 키 체인과 같다.   
사용자는 개인 키로 거래에 서명하여 자신이 에테르를 소유하고 있음을 증명한다. 에테르는 블록 체인에 저장된다.  
지갑에는 두 가지 주요 유형이 있는데, 지갑에 들어 있는 키가 서로 연관되어 있는지 여부에 따라 구별된다.  

-비결정론적지갑  
각 키가 서로 다른 난수에서 독립적으로 생성, 키는 서로 관련이 없다. 이 유형의 지갑은 "Just a Bunch of Keys"라는 문구에서 JBOK 지갑이라고한다.  

-결정론적지갑  
모든 키는 seed 라고하는 단일 마스터 키에서 파생, 모든 열쇠는 서로 연관되어 있으며, 원래 seed가 있으면 다시 생성 할 수 있다.  
결정론적지갑은 다양한 키 파생방법이 있다.  
가장 일반적인 방법은 계층적결정적지갑에서 설명된 대로 트리와 같은 구조를 사용한다  
휴대폰을 도난당하거나 변기에 떨어뜨리는것과 같은 데이터 손실 사고에 대비하여 결정론적지갑을 조금더 안전하게 만들기위해, seed는  사고 발생시 사용할 수 있도록 (영어 또는 다른 언어)으로 인코딩됩니다.  
이를 지갑의 니모닉 코드 단어라고 한다.  
누군가 당신의 니모닉 코드 단어를 손에 넣으면 지갑을 다시 만들어서 당신의 이더와 스마트 계약에 접근 할 수 있다.  
따라서 복구 단어 목록에 매우주의해야 한다. 컴퓨터 나 전화에 전자적으로 파일로 저장하지 마십시오.  
종이에 적어두고 안전한 곳에 보관해야한다.  
다음 몇 섹션에서는 이러한 각 기술을 높은 수준에서 소개합니다.  

## Nondeterministic (Random) Wallets
첫 번째 이더 리움 지갑 (이더 리움 사전 판매용으로 제작 됨)에서 각 지갑 파일은 임의로 생성 된 단일 개인 키를 저장한다.   
이러한 "구식"지갑은 여러면에서 열등하기 때문에 이러한 지갑은 결정적 지갑으로 대체된다.  
예를 들어, 이더 리움을 사용하는 동안 개인정보를 강화하기 위해 이더 리움 주소 재사용을 피하는 것이 좋다.   
즉, 자금을받을 때마다 새 주소 (새 개인 키가 필요함)를 사용하는 것입니다.   
토큰을 많이 처리하면 비용이 많이들고 각 거래에 대해 새 주소를 사용할 수 있다.   
이 관행을 따르려면 비 결정적 지갑이 정기적으로 키 목록을 늘려야하므로 정기적으로 백업한다. 지갑을 백업하기 전에 데이터를 분실하면 자금 및 스마트 계약에 대한 액세스 권한을 잃게됩니다.  
"유형 0"비 결정적 지갑은 "적시"방식으로 모든 새 주소에 대해 새 지갑 파일을 생성하기 때문에 처리하기 가장 어렵다.  
그럼에도 불구하고 많은 Ethereum 클라이언트 (geth 포함) 는 추가 보안을 위해 암호로 암호화 된 단일 (임의로 생성 된) 개인 키를 포함하는 JSON 인코딩 파일 인 키 저장소 파일을 사용합니다.    
다음은JSON 파일의 내용이다.  
```
{
    "address": "001d3f1ef827552ae1114027bd3ecf1f086ba0f9",
    "crypto": {
        "cipher": "aes-128-ctr",
        "ciphertext":
            "233a9f4d236ed0c13394b504b6da5df02587c8bf1ad8946f6f2b58f055507ece",
        "cipherparams": {
            "iv": "d10c6ec5bae81b6cb9144de81037fa15"
        },
        "kdf": "scrypt",
        "kdfparams": {
            "dklen": 32,
            "n": 262144,
            "p": 1,
            "r": 8,
            "salt":
                "99d37a47c7c9429c66976f643f386a61b78b97f3246adca89abe4245d2788407"
        },
        "mac": "594c8df1c8ee0ded8255a50caf07e8c12061fd859f4b7c76ab704b17c957e842"
    },
    "id": "4fcb2ba4-ccdb-424f-89d5-26cce304bf9c",
    "version": 3
}
```

키스토어 형식은 식은 무차별 대입, 사전 및 레인보우 테이블 공격으로부터 보호하는 암호 확장 알고리즘이라고도 하는 키 파생 함수 (KDF)를 사용한다.  
개인키는 암호문구로 직접 암호화 되지 않는다.   
대신 반복적으로 해싱하여 암호를 확장한다.   
해싱 함수는 262,144 라운드 동안 반복되며 키 저장소 JSON에서 crypto.kdfparams.n 매개 변수로 볼 수 있다.   
암호를 무차별 대입하려는 공격자는 시도 된 모든 암호에 대해 262,144 라운드의 해싱을 적용해야하므로 공격 속도가 충분히 느려져 충분히 복잡하고 길이가 긴 암호를 사용할 수 없게 만든다.  
자바스크립트 라이브러리 keythereum과 같이 키 저장소 형식을 읽고 쓸 수 있는 소프트웨어 라이브러리가 많이 있다.  
|  |  |  
|--|--|  
|팁|비결정론적 지갑의 사용은 단순한 시험 이외의 어떤 것에도 금물이다. 가장 기본적인 상황 외에는 어떤 것도 백업하고 사용하기에는 너무 번거롭다. 대신 백업에 니모닉 시드가 있는 업계 표준 기반 HD 지갑을 사용하십시오.|  

## Deterministic (Seeded) Wallets
결정적 또는 "시드"지갑은 단일 마스터 키 또는 시드에서 모두 파생 된 개인 키를 포함하는 지갑입니다.   
시드는 인덱스 번호 또는 "체인 코드"( 확장 공개 및 개인 키 참조)와 같은 다른 데이터와 결합되어 임의의 수의 개인 키를 도출한다.  
결정 론적 지갑에서 시드는 모든 파생 키를 복구하기에 충분하므로 생성시 단일 백업으로 지갑의 모든 자금과 스마트 계약을 보호하는 데 충분하다.   
시드는 지갑 내보내기 또는 가져 오기에도 충분하므로 서로 다른 지갑 구현간에 모든 키를 쉽게 마이그레이션 할 수 있다.
이 디자인은 전체 지갑에 대한 액세스 권한을 얻기 위해 시드 만 필요하기 때문에 시드의 보안을 가장 중요하게 만든다.   
반면에 단일 데이터에 보안 노력을 집중할 수 있다는 것은 장점으로 볼 수 있다.  


## Hierarchical Deterministic Wallets (BIP-32/BIP-44)



## Seeds and Mnemonic Codes (BIP-39)


# Wallet Best Practices


## Mnemonic Code Words (BIP-39)



## Generating mnemonic words
[Mnemonic codes: entropy and word length]
| Entropy  (bits) | Checksum  (bits) | Entropy + checksum  (bits) | Mnemonic length  (word) |    
|---|---|---|--|  
| 128 | 4 | 132 | 12 |    
| 160 | 5 | 165 | 15 |  
| 192 | 6 | 198 | 18 |  
| 224 | 7 | 231 | 21 |  
| 256 | 8 | 264 | 24 |  

![이미지1](https://github.com/ethereumbook/ethereumbook/raw/develop/images/bip39-part1.png)

![이미지2](https://github.com/ethereumbook/ethereumbook/raw/develop/images/bip39-part2.png)
## From mnemonic to seed


## Optional passphrase in BIP-39



## Working with mnemonic codes


## Creating an HD Wallet from the Seed


## HD Wallets (BIP-32) and Paths (BIP-43/44)


## Extended public and private keys



## Hardened child key derivation


## Index numbers for normal and hardened derivation


## HD wallet key identifier (path)


## Navigating the HD wallet tree structure


# Conclusion
