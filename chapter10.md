# Tokens
토큰은 사인 또는 심볼을 의미함  
주로 중요하지 않지만 내재적 가치를 가지고 특별한 목적으로 발행된 코인 같은 아이템을 말함  
예로써 교통 토큰, 세탁 토큰, 아케이드 게임 토큰 등이 있음  

블록체인에서 관리되는 토큰은 자산이나 통화, 접근 권한을 의미함  
토큰이란 단어와 중요하지 않은 가치의 결합은 물리적 버전의 토큰의 제한된 사용과 많은 관련이 있음   
물리적 토큰은 특정 비즈니스나 조직, 영역에 제한되어있고 교환이 쉽지 않으며, 한가지 기능만 수행함  
블록체인 토큰은 이런 제한을 벗어나서 다양한 목적으로 글로벌로 사용될 수 있음  
즉 서로 교역을 하거나 유동 시장에서 다른 화폐와 교환할 수 있음  

본 챕터에서는 토큰의 다양한 사용 사례를 보고, 토큰의 교환 기능과 본질 같은 특성을 공부함  
마지막으로 기반이 되는 표준 기술을 공부하고 직접 토큰을 발생해 본다  

# How Tokens Are Used
디지털 통화가 가장 명확한 토큰 사용예이나 이것만이 다는 아님   
많은 다른 기능을 할수있도록 프로그래밍할 수 있음  
아래 목록이 다양한 사용예임  

+ Currency  
토큰이 화폐 형태로써 작동할 수 있음  
가치는 개별적 거래를 통해서 결정 됨  
+ Resource  
토큰이 공유 경제에서 생산된 자원을 나타낼 수 있음  
예로서 네트워크에서 공유되는 저장소나 CPU 등  
+ Asset  
토큰이 내재적 또는 외재적 소유권이나 만질 수 있거나 없는 소유권을 나태닐 수 있음  
예로서 금이나 부동산, 차, 오일, 에너지, 게임 아이템 등  
+ Access  
토큰이 접근권한을 나타날 수 있고, 디지털이나 물리적 자산의 접근을 허용할 수 있음  
+ Equity  
토큰이 디지털 조직이나 법적 개체에게 지분증명을 나타낼 수 있음  
+ Voting  
토큰이 디지털이나 법률적 시스템에서 투표 권한을 나타낼 수 있음  
+ Collectable  
토큰이 디지털 수집품을 나타낼 수 있음(CryptoPunks, 그림등)  
+ Identity  
토큰이 디지털 신원이나 법적인 신원을 나타낼 수 있음  
+ Attestation  
토큰이 증명서를 나타낼 수 있음  
분산화된 평판 시스템이 될 수 있음  
+ Utility  
서비스를 위한 지불이나 접근용도로 사용될 수 있음  

한 개의 토큰이 위에 언급된 기능의 몇개를 포괄할 수 있음  
때로는 엄밀하게 분류하기가 어렵기도 하다  
예로서 운전자 면허증(증명서)이 신원 증명서(신원확인)가 될 수 있으나, 그 두가지를 분류할 수는 없음  

# Tokens and Fungibility
경제학에선 교환성은 상품의 자산이 개별 단위로 교환할 수 있는 것임  
토큰도 개별 단위로 교환할 수 있음  
엄밀히 말해서 토큰의 사용 출처를 추적할 수 있다면 완전히 교환할 수 없다  
출처를 추적하는 능력이 블랙리스팅이나 화이트리스팅을 야기할 수 있고,  
교환성을 줄이거나 제거할 수 도 있음  

비교환성 토큰도 고유한 유무형의 아이템을 나타내는 토큰임  
따라서 상호 교환되지 않음  
예로서 반고흐 그림의 소유권을 나타내는 토큰은 피카소 그림을 나타내는 다른 토큰과는 일치하지 않음  
유사하게 특정한 크립토키티 같은 디지털 수집물인 토큰은 다른 크립토키티와 상호 교환되지 않음  
각각의 비교환 토큰은 고유한 식별자와 겹합되어 있음(시리얼 넘버)  
|  |  |
|--|--|
|Note|교환가능은 돈으로 직접적으로 바꿀 수 있음을 의미함. 하지만 여기선 그런 의미로 사용하지 않음|

# Counterparty Risk(거래상대방 리스크)
거래상대방 리스크는 거래의 상대편이 자신의 의무를 지키지 않는 것임  
복수의 거래자가 참여하는 거래상대방 리스크도 있음  
예로서 당신이 값비싼 금속의 예치 증명서를 가지고 있고, 당신이 누군가에게 팔려고 한다면,  
바로 이런 거래에서 최소한 세명의 참여자가 있음: 판매자, 구입자, 보관자  
누군가 물리적 자산을 가지고 있고; 필수적으로 그들은 거래 이행의 참여자가 되고,  
해당 자산을 관련된 거래에서 거래상대방 리스크가 존재하게 됨  
비디지털 세계에서처럼 디지털 토큰의 세계에서도 토큰으로 표현되는 자산을 누가 가지고 있고 무슨 규칙이 존재하는지 이해하는게 중요함  

# Tokens and Intrinsicality(토큰과 본질)
어떤 토큰은 블록체인의 본질인 디지털 아이템을 나타냄  
그런 디지털 토큰들은 컨센서스 규칙에 의해서 처리됨  
본질적 자산을 나타내는 토큰은 추가적인 거래상대방 리스크가 없음  
당신이 크립토키티에 키를 소유하고 있으면 당신 이외에 해당 크립토키티를 가진자는 없음(직접 소유하는 것임)    
블록체인 컨센서스 규칙이 적용되면 비밀키 소유권이 자신의 소유권가 동치가 됨  
어떤 중개자도 없음  

역으로 많은 토큰들이 외부적인 것을 나타내기 위해서 사용됨  
부동산, 법인 투표 지분, 상표권, 골드바 등  
이런 블록체인 내부에 없는 아이템들의 소유권은 법이나 관습, 정책 같은 것에 의해서 다뤄짐  
토큰을 조정하는 컨센서스 규칙과 분리되어 있음  
즉, 토큰 발행자와 소유자가 현실 세계의 비 스마트컨트랙트에 여전히 의존함  
따라서 이런 외부적 자산은 추가적인 거래상대방 리스크가 존재함  
왜냐하면 블록체인 환경 밖에 있는 보관자나 등기소 또는 법이나 정책에 의해서 조정되기 때문임  

블록체인 기반 토큰의 가장 중요한 결과는 외재적 자산을 내재적 자산으로 전환할 수 있는 능력임  
그에의해서 거래상대방 리스크를 없앰  
좋은 예로서 회사의 지분에서 DAO나 조직의 투표 토큰으로 변환할 수 있음  

# Using Tokens: Utility or Equity
거의 대부분의 프로젝트들이 요즘엔 토큰을 발행함  
하지만 그 프로젝트들이 정말 토큰이 필요할까?  
모든 것을 토큰화하는 것이 실효성이 있을까?  
원론적으로 토큰의 사용이 궁극의 조직 관리 툴로 보일 수 있음  
하지만 실제 적용엔 많은 제한사항이 있음  

대부분의 프로젝트가 두 가지 중의 하나로 토큰을 사용하고 있음  
즉, 유틸리티 토큰과 지분 토큰.  
하지만 위 두 가지 역할이 강하게 결합돼 있음  

유틸리티 토큰은 서비스나 어플, 자원 등에 접근 허용 용도로 사용됨  

지분 토큰은 스타트업과 같은 조직의 소유권을 나타내는데 사용됨  

#### It's a Duck!

많은 스타트업이 어려운 문제에 직면함: 토큰이 엄청난 자금모집 메커니즘이나,  
대중에게 증권 제공은 대부분의 사법기관에서 규제되는 활동임  
스타트업이 유틸리티 토큰이라며 프리 세일로 서비스 접근 바우처로 판매하지만,  
규제당국은 지분 제공으로 보고 감시할 수 있음  

"오리처럼 걷고, 소리낸다면 그것은 오리임" 이라는 속담처럼  
당국에서는 대중을 속이려하는 자들을 감시할 것임  

# Utility Tokens: 누가 필요한가?
실제적인 문제는 대중은 아직 토큰을 암호화폐의 하나로 보는 것임  

유틸리티 토큰을 P2P 네트워크에서 사용하는 것처럼 혁신적인 서비스는   
시장에 안착하는 것이 쉽지 않음  

스타트업은 다음과 같이 질문해야함  
이익과 열정이 리스크와 불확실성을 넘어서는가?  

# Tokens on Ethereum
이더리움 탄생 전에 블록체인 토큰이 존재했음  
어떤면에서는 비트코인 자체가 토큰임  
하지만, 이더리움의 첫 토큰 표준의 도입이 토큰의 확장을 이끎  

토큰은 이더와 다르다  
이더리움 프로토콜은 토큰에 대한 어떤 것도 알지 못함  
이더를 보내는 것이 이더리움 플랫폼의 본질적 행위이나  
토큰을 보내고 소유하는 것은 관련이 없음   
이더리움 계정의 이더 잔액은 프로토콜 단계에서 다뤄지나  
이더리움 계정의 토큰 잔액은 스마트컨트랙트 단계에서 다룸  
이더리움에서 새로운 토큰을 생성하기 위해선 새로운 스마트컨트랙트를 생성해야함  
일단 스마트컨트랙트가 배포되면 소유권, 전송, 접근 권한을 포함한 모든 것을 조정할 수 있음  

# The ERC20 Token Standard
Fabian Vogelsteller 가 Ethereaum Request for Comments(ERC) 2015년 11월 첫 표준을 소개함  
ERC20 Token 으로 명명됨   
ERC20 은 나중에 Ethereum Improvement Proposal 20(EIP-20) 이 되나, 주로 ERC20으로 칭해짐  

ERC20 은 교환가능한 토큰의 표준이 됨.  
따라서 다른 ERC20 토큰들과 상호교환이 가능하고, 고유한 속성은 없음  

ERC20 표준은 토큰을 구현한 컨트랙트의 공통 인터페이스를 정의한 것임  
그에따라서 다른 토큰들에 접근하여 같은 방식으로 사용될 수 있음  
인터페이스는 표준 기능에 필요한 함수들로 구성되어 있고,  
일부 옵션인 함수와 속성을 개발자가 추가할 수 있음  

### ERC20 required functions and events
ERC20을 준수하는 토큰 컨트랙트는 최소한 다음의 함수와 이벤트를 제공해야함  

+ totalSupply
현재 존재하는 토큰의 총 단위 값을 알려줌  
+ balanceOf
주어진 주소의 잔고값을 알 수 있음  
+ trasfer
주소와 금액이 인자로 주워지고, 본 함수를 시행하는 자의 잔고에서 인자의 주소로 해당 금액만큼 전송함   
+ transferFrom
보내는자, 수령자, 금액을 인자로 넣음  
한 잔고에서 다른 잔고로 보낼때 사용되고 아래 apporve 와 함께 사용됨  
+ approve
수령자 주소와 금액을 인자로 주워짐  
+ allowance
소유자 주소와 사용자 주소가 주워지며,  
리턴값은 사용자에게 소유자로부터 인출 허용된 남은 양임  
+ Transfer  
성공적인 transfer or transferFrom 시에 발생하는 이벤트임  
+ Approval
approve 호출이 성공했을 시에 발생하는 이벤트 로그  

### ERC20 optional functions
옵션 함수 목륵은 다음과 같음  

+ name  
사람이 읽을 수 있는 형태의 토큰 이름을 알려줌 (US Dollars)  
+ symbol  
토큰의 심볼을 알려줌(USD)  
+ decimals  
토큰의 수량을 나누기 위해서 사용되는 소수점 값을 알려줌  

### The ERC20 interface defined in Solidity
```
contract ERC20 {
   function totalSupply() constant returns (uint theTotalSupply);
   function balanceOf(address _owner) constant returns (uint balance);
   function transfer(address _to, uint _value) returns (bool success);
   function transferFrom(address _from, address _to, uint _value) returns
      (bool success);
   function approve(address _spender, uint _value) returns (bool success);
   function allowance(address _owner, address _spender) constant returns
      (uint remaining);
   event Transfer(address indexed _from, address indexed _to, uint _value);
   event Approval(address indexed _owner, address indexed _spender, uint _value);
}
```

### ERC20 data structures
ERC20 은 2 가지 데이터 구조체를 가짐  
하나는 잔고 추적용도이고  
또하나는 허가여부를 추적하는 용도임  
위 데이터 구조체는 mapping 형으로 구현됨  

소유에 대한 데이터 매핑은 아래와 같은 형태로 구현되고  
모든 transfer 은 단순히 한 잔고에서 빼고, 다른 잔고로 더 해주는 것임  
```
mapping(address => uint256) balances;
```

두 번째 데이터 구조체는 허용여부의 데이터 매핑이고 아래 형태와 같음  
ERC20 컨트랙트는 2차원 매핑으로 허용여부를 추적하고,  
토큰 소유자의 주소로 주요 키로 해서, 사용자 주소와 허용한 금액을 매핑함  
```
mapping (address => mapping (address => uint256)) public allowed;
```

# ERC20 workflows: "transfer" and "approve & transferFrom"
ERC20 토큰 표준은 2 개의 전송 함수가 있음  

ERC20 은 2 가지 워크플로우를 허용함  
첫번째는 transfer 함수를 통해서 싱글 트랜잭션으로 직접적으로 처림함  
이런 워크플로우는 지갑에서 지갑으로 토큰을 보낼때 사용됨  
대부분의 토큰 트랜잭션이 transfer 워크플로우를 통해서 처리됨  

두번째는 2 단계 트랜잭션이 필요한 워크플로우임  
approve 이후에 transferFrom 을 통해서 처리함  
이번 워크플로우는 토큰 소유자가 자신의 제어권을 다른 주소에게 허용하는 것임  
이런 워크플로우는 컨트랙트의 토큰 분배시에 권한을 위임할 때 종종 사용됨  
예 거래소, 크라우드세일, ICO 등  
|  |  |
|--|--|
|Note|Initial Coin Offering(ICO) 의 용어는 주식 공개 시장에서 사용되는 Initial Public Offering(IPO) 에서 유래함|  















