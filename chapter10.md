# Tokens
토큰은 사인 또는 심볼을 의미함  
주로 중요하지 않지만 내재적 가치를 가지고 특별한 목적으로 발행된 코인 같은 아이템을 말함  
예로써 교통 토큰, 세탁 토큰, 아케이드 게임 토큰 등이 있음  

블록체인에서 관리되는 토큰은 자산이나 통화, 접근 권한을 의미함  
토큰이란 단어와 중요하지 않은 가치의 결합은 물리적 버전의 토큰의 제한된 사용과 많은 관련이 있음   
물리적 토큰은 특정 비즈니스나 조직, 영역에 제한되어있고 교환이 쉽지 않으며, 한가지 기능만 수행함  
블록체인 토큰은 이런 제한을 벗어나서 다양한 목적으로 글로벌로 사용될 수 있음  
즉 서로 교역을 하거나 유동 시장에서 다른 화폐와 교환할 수 있음  

본 챕터에서는 토큰의 다양한 사용 사례를 보고, 토큰의 교환 기능과 본질 같은 특성을 공부함  
마지막으로 기반이 되는 표준 기술을 공부하고 직접 토큰을 발생해 본다  

# How Tokens Are Used
디지털 통화가 가장 명확한 토큰 사용예이나 이것만이 다는 아님   
많은 다른 기능을 할수있도록 프로그래밍할 수 있음  
아래 목록이 다양한 사용예임  

+ Currency  
토큰이 화폐 형태로써 작동할 수 있음  
가치는 개별적 거래를 통해서 결정 됨  
+ Resource  
토큰이 공유 경제에서 생산된 자원을 나타낼 수 있음  
예로서 네트워크에서 공유되는 저장소나 CPU 등  
+ Asset  
토큰이 내재적 또는 외재적 소유권이나 만질 수 있거나 없는 소유권을 나태닐 수 있음  
예로서 금이나 부동산, 차, 오일, 에너지, 게임 아이템 등  
+ Access  
토큰이 접근권한을 나타날 수 있고, 디지털이나 물리적 자산의 접근을 허용할 수 있음  
+ Equity  
토큰이 디지털 조직이나 법적 개체에게 지분증명을 나타낼 수 있음  
+ Voting  
토큰이 디지털이나 법률적 시스템에서 투표 권한을 나타낼 수 있음  
+ Collectable  
토큰이 디지털 수집품을 나타낼 수 있음(CryptoPunks, 그림등)  
+ Identity  
토큰이 디지털 신원이나 법적인 신원을 나타낼 수 있음  
+ Attestation  
토큰이 증명서를 나타낼 수 있음  
분산화된 평판 시스템이 될 수 있음  
+ Utility  
서비스를 위한 지불이나 접근용도로 사용될 수 있음  

한 개의 토큰이 위에 언급된 기능의 몇개를 포괄할 수 있음  
때로는 엄밀하게 분류하기가 어렵기도 하다  
예로서 운전자 면허증(증명서)이 신원 증명서(신원확인)가 될 수 있으나, 그 두가지를 분류할 수는 없음  

# Tokens and Fungibility
경제학에선 교환성은 상품의 자산이 개별 단위로 교환할 수 있는 것임  
토큰도 개별 단위로 교환할 수 있음  
엄밀히 말해서 토큰의 사용 출처를 추적할 수 있다면 완전히 교환할 수 없다  
출처를 추적하는 능력이 블랙리스팅이나 화이트리스팅을 야기할 수 있고,  
교환성을 줄이거나 제거할 수 도 있음  

비교환성 토큰도 고유한 유무형의 아이템을 나타내는 토큰임  
따라서 상호 교환되지 않음  
예로서 반고흐 그림의 소유권을 나타내는 토큰은 피카소 그림을 나타내는 다른 토큰과는 일치하지 않음  
유사하게 특정한 크립토키티 같은 디지털 수집물인 토큰은 다른 크립토키티와 상호 교환되지 않음  
각각의 비교환 토큰은 고유한 식별자와 겹합되어 있음(시리얼 넘버)  
|  |  |
|--|--|
|Note|교환가능은 돈으로 직접적으로 바꿀 수 있음을 의미함. 하지만 여기선 그런 의미로 사용하지 않음|

# Counterparty Risk(거래상대방 리스크)
거래상대방 리스크는 거래의 상대편이 자신의 의무를 지키지 않는 것임  
복수의 거래자가 참여하는 거래상대방 리스크도 있음  
예로서 당신이 값비싼 금속의 예치 증명서를 가지고 있고, 당신이 누군가에게 팔려고 한다면,  
바로 이런 거래에서 최소한 세명의 참여자가 있음: 판매자, 구입자, 보관자  
누군가 물리적 자산을 가지고 있고; 필수적으로 그들은 거래 이행의 참여자가 되고,  
해당 자산을 관련된 거래에서 거래상대방 리스크가 존재하게 됨  
비디지털 세계에서처럼 디지털 토큰의 세계에서도 토큰으로 표현되는 자산을 누가 가지고 있고 무슨 규칙이 존재하는지 이해하는게 중요함  

# Tokens and Intrinsicality(토큰과 본질)
어떤 토큰은 블록체인의 본질인 디지털 아이템을 나타냄  
그런 디지털 토큰들은 컨센서스 규칙에 의해서 처리됨  
본질적 자산을 나타내는 토큰은 추가적인 거래상대방 리스크가 없음  
당신이 크립토키티에 키를 소유하고 있으면 당신 이외에 해당 크립토키티를 가진자는 없음(직접 소유하는 것임)    
블록체인 컨센서스 규칙이 적용되면 비밀키 소유권이 자신의 소유권가 동치가 됨  
어떤 중개자도 없음  

역으로 많은 토큰들이 외부적인 것을 나타내기 위해서 사용됨  
부동산, 법인 투표 지분, 상표권, 골드바 등  
이런 블록체인 내부에 없는 아이템들의 소유권은 법이나 관습, 정책 같은 것에 의해서 다뤄짐  
토큰을 조정하는 컨센서스 규칙과 분리되어 있음  
즉, 토큰 발행자와 소유자가 현실 세계의 비 스마트컨트랙트에 여전히 의존함  
따라서 이런 외부적 자산은 추가적인 거래상대방 리스크가 존재함  
왜냐하면 블록체인 환경 밖에 있는 보관자나 등기소 또는 법이나 정책에 의해서 조정되기 때문임  

블록체인 기반 토큰의 가장 중요한 결과는 외재적 자산을 내재적 자산으로 전환할 수 있는 능력임  
그에의해서 거래상대방 리스크를 없앰  
좋은 예로서 회사의 지분에서 DAO나 조직의 투표 토큰으로 변환할 수 있음  

# Using Tokens: Utility or Equity
거의 대부분의 프로젝트들이 요즘엔 토큰을 발행함  
하지만 그 프로젝트들이 정말 토큰이 필요할까?  
모든 것을 토큰화하는 것이 실효성이 있을까?  
원론적으로 토큰의 사용이 궁극의 조직 관리 툴로 보일 수 있음  
하지만 실제 적용엔 많은 제한사항이 있음  

대부분의 프로젝트가 두 가지 중의 하나로 토큰을 사용하고 있음  
즉, 유틸리티 토큰과 지분 토큰.  
하지만 위 두 가지 역할이 강하게 결합돼 있음  

유틸리티 토큰은 서비스나 어플, 자원 등에 접근 허용 용도로 사용됨  

지분 토큰은 스타트업과 같은 조직의 소유권을 나타내는데 사용됨  

#### It's a Duck!

많은 스타트업이 어려운 문제에 직면함: 토큰이 엄청난 자금모집 메커니즘이나,  
대중에게 증권 제공은 대부분의 사법기관에서 규제되는 활동임  
스타트업이 유틸리티 토큰이라며 프리 세일로 서비스 접근 바우처로 판매하지만,  
규제당국은 지분 제공으로 보고 감시할 수 있음  

"오리처럼 걷고, 소리낸다면 그것은 오리임" 이라는 속담처럼  
당국에서는 대중을 속이려하는 자들을 감시할 것임  

# Utility Tokens: 누가 필요한가?
실제적인 문제는 대중은 아직 토큰을 암호화폐의 하나로 보는 것임  

유틸리티 토큰을 P2P 네트워크에서 사용하는 것처럼 혁신적인 서비스는   
시장에 안착하는 것이 쉽지 않음  

스타트업은 다음과 같이 질문해야함  
이익과 열정이 리스크와 불확실성을 넘어서는가?  

# Tokens on Ethereum
이더리움 탄생 전에 블록체인 토큰이 존재했음  
어떤면에서는 비트코인 자체가 토큰임  
하지만, 이더리움의 첫 토큰 표준의 도입이 토큰의 확장을 이끎  

토큰은 이더와 다르다  
이더리움 프로토콜은 토큰에 대한 어떤 것도 알지 못함  
이더를 보내는 것이 이더리움 플랫폼의 본질적 행위이나  
토큰을 보내고 소유하는 것은 관련이 없음   
이더리움 계정의 이더 잔액은 프로토콜 단계에서 다뤄지나  
이더리움 계정의 토큰 잔액은 스마트컨트랙트 단계에서 다룸  
이더리움에서 새로운 토큰을 생성하기 위해선 새로운 스마트컨트랙트를 생성해야함  
일단 스마트컨트랙트가 배포되면 소유권, 전송, 접근 권한을 포함한 모든 것을 조정할 수 있음  

# The ERC20 Token Standard
Fabian Vogelsteller 가 Ethereaum Request for Comments(ERC) 2015년 11월 첫 표준을 소개함  
ERC20 Token 으로 명명됨   
ERC20 은 나중에 Ethereum Improvement Proposal 20(EIP-20) 이 되나, 주로 ERC20으로 칭해짐  

ERC20 은 교환가능한 토큰의 표준이 됨.  
따라서 다른 ERC20 토큰들과 상호교환이 가능하고, 고유한 속성은 없음  

ERC20 표준은 토큰을 구현한 컨트랙트의 공통 인터페이스를 정의한 것임  
그에따라서 다른 토큰들에 접근하여 같은 방식으로 사용될 수 있음  
인터페이스는 표준 기능에 필요한 함수들로 구성되어 있고,  
일부 옵션인 함수와 속성을 개발자가 추가할 수 있음  

### ERC20 required functions and events
ERC20을 준수하는 토큰 컨트랙트는 최소한 다음의 함수와 이벤트를 제공해야함  

+ totalSupply
현재 존재하는 토큰의 총 단위 값을 알려줌  
+ balanceOf
주어진 주소의 잔고값을 알 수 있음  
+ trasfer
주소와 금액이 인자로 주워지고, 본 함수를 시행하는 자의 잔고에서 인자의 주소로 해당 금액만큼 전송함   
+ transferFrom
보내는자, 수령자, 금액을 인자로 넣음  
한 잔고에서 다른 잔고로 보낼때 사용되고 아래 apporve 와 함께 사용됨  
+ approve
수령자 주소와 금액을 인자로 주워짐  
+ allowance
소유자 주소와 사용자 주소가 주워지며,  
리턴값은 사용자에게 소유자로부터 인출 허용된 남은 양임  
+ Transfer  
성공적인 transfer or transferFrom 시에 발생하는 이벤트임  
+ Approval
approve 호출이 성공했을 시에 발생하는 이벤트 로그  

### ERC20 optional functions
옵션 함수 목륵은 다음과 같음  

+ name  
사람이 읽을 수 있는 형태의 토큰 이름을 알려줌 (US Dollars)  
+ symbol  
토큰의 심볼을 알려줌(USD)  
+ decimals  
토큰의 수량을 나누기 위해서 사용되는 소수점 값을 알려줌  

### The ERC20 interface defined in Solidity
```
contract ERC20 {
   function totalSupply() constant returns (uint theTotalSupply);
   function balanceOf(address _owner) constant returns (uint balance);
   function transfer(address _to, uint _value) returns (bool success);
   function transferFrom(address _from, address _to, uint _value) returns
      (bool success);
   function approve(address _spender, uint _value) returns (bool success);
   function allowance(address _owner, address _spender) constant returns
      (uint remaining);
   event Transfer(address indexed _from, address indexed _to, uint _value);
   event Approval(address indexed _owner, address indexed _spender, uint _value);
}
```

### ERC20 data structures
ERC20 은 2 가지 데이터 구조체를 가짐  
하나는 잔고 추적용도이고  
또하나는 허가여부를 추적하는 용도임  
위 데이터 구조체는 mapping 형으로 구현됨  

소유에 대한 데이터 매핑은 아래와 같은 형태로 구현되고  
모든 transfer 은 단순히 한 잔고에서 빼고, 다른 잔고로 더 해주는 것임  
```
mapping(address => uint256) balances;
```

두 번째 데이터 구조체는 허용여부의 데이터 매핑이고 아래 형태와 같음  
ERC20 컨트랙트는 2차원 매핑으로 허용여부를 추적하고,  
토큰 소유자의 주소로 주요 키로 해서, 사용자 주소와 허용한 금액을 매핑함  
```
mapping (address => mapping (address => uint256)) public allowed;
```

## ERC20 workflows: "transfer" and "approve & transferFrom"
ERC20 토큰 표준은 2 개의 전송 함수가 있음  

ERC20 은 2 가지 워크플로우를 허용함  
첫번째는 transfer 함수를 통해서 싱글 트랜잭션으로 직접적으로 처림함  
이런 워크플로우는 지갑에서 지갑으로 토큰을 보낼때 사용됨  
대부분의 토큰 트랜잭션이 transfer 워크플로우를 통해서 처리됨  

두번째는 2 단계 트랜잭션이 필요한 워크플로우임  
approve 이후에 transferFrom 을 통해서 처리함  
이번 워크플로우는 토큰 소유자가 자신의 제어권을 다른 주소에게 허용하는 것임  
이런 워크플로우는 컨트랙트의 토큰 분배시에 권한을 위임할 때 종종 사용됨  
예 거래소, 크라우드세일, ICO 등  
|  |  |
|--|--|
|Note|Initial Coin Offering(ICO) 의 용어는 주식 공개 시장에서 사용되는 Initial Public Offering(IPO) 에서 유래함|  

![alt text](https://github.com/ethereumbook/ethereumbook/raw/develop/images/approve_transferFrom_workflow.png)

<br>

approve & transferFrom 워크플로우는 2 단계 트랜잭션이 필요함   
위 그림에서 Alice 가 AliceCoin 토큰 구매자인 Bob 에게 절반의 토큰 판매를 허용하기 원함  
Alice 가 AliceCoin ERC20 컨트랙트를 발행하고 모든 초기 토큰을 자신의 주소로 보냄  
또한 Alice 는 이더로 토큰을 살 수 있는 AliceICO 컨트랙트를 발행함  
다음으로 Alice 는 approve & transferFrom 워크플로우를 가동함  
Alice는 AliceCoin 컨트랙트로 총 토큰의 절반값과 AliceICO 컨트랙트 주소를 인자값으로 허용을 요청하는 approve 을 호출함  
이것은 Approval 이벤트를 발생시킴  
이제 AliceICO 컨트랙트는 AliceCoin 을 판매할 수 있게 됨  

AliceICO 컨트랙트가 Bob 에게서 이더를 받게되면, AliceCoin 을 Bob 에게 보내는 것임 필요힘   
AliceICO 컨트랙트내에 AliceCoin 과 이더의 교환 비율이 설정되어 있음  
AliceICO 컨트랙트가 AliceCoin transferForm 함수를 호출할때  
Alice 주소를 보내는자로 Bob 주소를 수령자로 설정하고  
얼만큼의 AliceCoin 토큰이 Bob 에게 전송되어야 하는지 교환 비율값을 인자로 사용할 수 있음   
AliceCoin 컨트랙트는 Alice 주소로부터 Bob 주소로 잔액을 전송하고  
이때 Transfer 이벤트가 발생함  
AliceICO 컨트랙트는 Alice 가 설정한 허용한도내에서 transferFrom 함수을 여려 차례 호출할 수 있음  
AliceICO 컨트랙트는 얼마만큼의 AliceCoin 토큰이 허용여부 함수 호출로 판매할 수 있는지 추적할 수 있음  

### ERC20 implementations(구현)  
ERC20 기준 준수 토큰은 솔리디티 코드 30 라인으로 구현 가능함  
EIP-20 표준에서 언급되는 2 가지 구현물이 있음  

+ Consensys EIP20  
ERC20 기준 준수 토큰이고 단순하고 보기 쉬운 구현물임   
+ OpenZeppelin StandardToken  
추가적인 보안 주의사항이 강화되었고, 펀딩 갭, 경매방식, 투자 스케줄과 같은 기능을 OpenZeppelin 라이브러리를 통해서 사용할 수 있음  

# Launching Our Own ERC20 Token
토큰을 직접 만들어 발생해 보자  
아래 예제를 실행하기 위해선 Truffle 프레임워크 설치해야 함  
아래 토큰은 "Mastering Ethereum Token" 이라고하고, 심볼은 "MET"  

아래와 같이 Truffle 프로젝트 디렉토리를 초기화 하고, 모든 질문에 디폴드 응답을 함  
```
$ mkdir METoken
$ cd METoken
METoken $ truffle init
METoken $ npm init
```
그러면 아래와 같은 디렉토리 구조가 나옴  
```
METoken/
+---- contracts
|   `---- Migrations.sol
+---- migrations
|   `---- 1_initial_migration.js
+---- package.json
+---- test
`---- truffle-config.js
```
truffle-config.js 설정 파일을 자신의 Truffle 환경에 맞게 설정함  
자신의 테스트 비밀키나 배포를 위한 환경 정보는 같은 폴더의 .env 확장자로 저장함  
자신의 MetaMask 로 부터 테스트 네트워크 비밀키를 추출할 수도 있음  
최종 디렉토리 구조는 아래 처럼 보일 것임  
```
METoken/
+---- contracts
|   `---- Migrations.sol
+---- migrations
|   `---- 1_initial_migration.js
+---- package.json
+---- test
+---- truffle-config.js
`---- .env *new file*
```

OpenZeppelin 라이브러리는 아래와 같이 설치할 수 있음  
```
$ npm install openzeppelin-solidity@1.12.0

+ openzeppelin-solidity@1.12.0
added 1 package from 1 contributor and audited 2381 packages in 4.074s
```
openzeppelin-solidity 팩키지는 250 개 파일을 node_modules 디렉토리 아래에 추가함   
OpenZeppelin 라이브러리는 ERC20 토큰 이외에 많은 기능이 있으나 여기선 일부만 사용함   

METoken.sol 이라는 명으로 토큰 컨트랙트를 작성하자. 소스코드는 Github 링크주소에서 받음  

```
link:code/truffle/METoken/contracts/METoken.sol[]
```
METoken.sol 구조는 소스코드를 직접 확인하라  
아래와 같이 truffle 로 컴파일한다  
```
$ truffle compile
Compiling ./contracts/METoken.sol...
Compiling ./contracts/Migrations.sol...
Compiling openzeppelin-solidity/contracts/math/SafeMath.sol...
Compiling openzeppelin-solidity/contracts/token/ERC20/BasicToken.sol...
Compiling openzeppelin-solidity/contracts/token/ERC20/ERC20.sol...
Compiling openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol...
Compiling openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol...
```
위에 보이는 것처럼 truffle 이 OpenZeppelin 라이브러리로 부터 필요한 의존성을 끌어와서 컴파일 함  

다음으로 METoken 컨트랙트를 배포하기 위해서 migration 스크립트를 사용함  
2_deploy_contracts: METoken 배포하기 위한 전환  
```
link:code/truffle/METoken/migrations/2_deploy_contracts.js[]
```
이더리움 테스트 네트워크에 배포하기전에 로컬 블록체인을 가동하자   
ganache 블록체인을 시작하고, 아래처럼 커맨드 라인으로 가능함  
ganache 가 가동되어야 METoken 컨트랙트를 배포할 수 있다  
```
$ truffle migrate --network ganache
Using network 'ganache'.

Running migration: 1_initial_migration.js
  Deploying Migrations...
  ... 0xb2e90a056dc6ad8e654683921fc613c796a03b89df6760ec1db1084ea4a084eb
  Migrations: 0x8cdaf0cd259887258bc13a92c0a6da92698644c0
Saving successful migration to network...
  ... 0xd7bc86d31bee32fa3988f1c1eabce403a1b5d570340a3a9cdba53a472ee8c956
Saving artifacts...
Running migration: 2_deploy_contracts.js
  Deploying METoken...
  ... 0xbe9290d59678b412e60ed6aefedb17364f4ad2977cfb2076b9b8ad415c5dc9f0
  METoken: 0x345ca3e014aaf5dca488057592ee47305d9b3e10
Saving successful migration to network...
  ... 0xf36163615f41ef7ed8f4a8f192149a0bf633fe1a2398ce001bf44c43dc7bdda0
Saving artifacts...
```
ganache 콘솔에서 배포작업을 통해서 새로운 트랜잭션 생성된 것을 아래처럼 볼 수 있음  
![가나시 확인](https://github.com/ethereumbook/ethereumbook/raw/develop/images/ganache_metoken.png)
<br>

## Interacting with METoken using the Truffle console
ganache 블록체인에 Truffle 콘솔에 아래처럼 접속할 수 있음
```
$ truffle console --network ganache
truffle(ganache)>
```
위  > 프롬프트가 ganache 블록체인에 접속되었음을 나타냄.
"METoken" 이라고 프롬프트에 타입핑하면 아래와 같은 전체 컨트랙트 정의를 덤프함
```
truffle(ganache)> METoken
{ [Function: TruffleContract]
  _static_methods:

[...]

currentProvider:
 HttpProvider {
   host: 'http://localhost:7545',
   timeout: 0,
   user: undefined,
   password: undefined,
   headers: undefined,
   send: [Function],
   sendAsync: [Function],
   _alreadyWrapped: true },
network_id: '5777' }
```

아래와 같이 METoken 의 속성도 출력할 수 있음
```
truffle(ganache)> METoken.address
'0x345ca3e014aaf5dca488057592ee47305d9b3e10'
```
배포된 컨트랙트와 상호작용하기 위해선 비동기 호출인 자바스크립트 "promise" 를 사용함.
아래는 그 사용례를 보여줌. 전체 공급량을 출력함.
```
truffle(ganache)> METoken.deployed().then(instance => instance.totalSupply())
BigNumber { s: 1, e: 9, c: [ 2100000000 ] }
```
다음으로 ganache 에 의해 생성된 계좌으로 METoken 잔액 확인하고, 다른 주소에 METoken 을 보내보자. 먼저 계좌를 만들자.
```
truffle(ganache)> let accounts
undefined
truffle(ganache)> web3.eth.getAccounts((err,res) => { accounts = res })
undefined
truffle(ganache)> accounts[0]
'0x627306090abab3a6e1400e9345bc60c78a8bef57'
```
accounts[0] 이 METoken 컨트랙트를 배포한 계좌임. 이 계좌가 METoekn 잔액을 가지고 있음. 잔액을 확인해 보자.
```
truffle(ganache)> METoken.deployed().then(instance =>
                  { instance.balanceOf(accounts[0]).then(console.log) })
undefined
truffle(ganache)> BigNumber { s: 1, e: 9, c: [ 2100000000 ] }
```
마지막으로 1000.00 METoken 을 accounts[0] 에서 accounts[1] 로 전송하자.
```
truffle(ganache)> METoken.deployed().then(instance =>
                  { instance.transfer(accounts[1], 100000) })
undefined
truffle(ganache)> METoken.deployed().then(instance =>
                  { instance.balanceOf(accounts[0]).then(console.log) })
undefined
truffle(ganache)> BigNumber { s: 1, e: 9, c: [ 2099900000 ] }
undefined
truffle(ganache)> METoken.deployed().then(instance =>
                  { instance.balanceOf(accounts[1]).then(console.log) })
undefined
truffle(ganache)> BigNumber { s: 1, e: 5, c: [ 100000 ] }
```
|  |  |
|--|--|
|Tip|METoken 2 decimals 정확도를 가짐. 1 METoken 은 100 단위를 나타냄. 1,000 METoken 을 보내려면, 전송 함수에 100000 을 입력함|   

ganache 그래픽 사용자 인터페이스로 전환하면 아래와 같이 전송이력을 확인할 수 있음  
![gui](https://github.com/ethereumbook/ethereumbook/raw/develop/images/ganache_metoken_transfer.png)  


## Sending ERC20 tokens to contract addresses
지금까지 ERC20 토큰을 설정하고 한 계좌에서 다른 계좌로 토큰을 전송했다. 지금까지 방식은 EOA 방식이므로 컨트랙트가 아닌 개인키를 통해서 조정했음  
이제 MET 를 컨트랙트 주소에 전달해보자  
아래와 같이 테스트 환경에 또하나의 컨트랙트를 배포하자 Faucet.sol 을 배포하면 아래와 같음.  
```
METoken/
+---- contracts
|   +---- Faucet.sol
|   +---- METoken.sol
|   `---- Migrations.sol
```
migration 은 아래와 같이 수정함  
```
var Faucet = artifacts.require("Faucet");

module.exports = function(deployer) {
  // Deploy the Faucet contract as our only task
  deployer.deploy(Faucet);
};
```
컴파일하고 마이그레이트 함  
```
$ truffle console --network ganache
truffle(ganache)> compile
Compiling ./contracts/Faucet.sol...
Writing artifacts to ./build/contracts

truffle(ganache)> migrate
Using network 'ganache'.

Running migration: 1_initial_migration.js
  Deploying Migrations...
  ... 0x89f6a7bd2a596829c60a483ec99665c7af71e68c77a417fab503c394fcd7a0c9
  Migrations: 0xa1ccce36fb823810e729dce293b75f40fb6ea9c9
Saving artifacts...
Running migration: 2_deploy_contracts.js
  Replacing METoken...
  ... 0x28d0da26f48765f67e133e99dd275fac6a25fdfec6594060fd1a0e09a99b44ba
  METoken: 0x7d6bf9d5914d37bcba9d46df7107e71c59f3791f
Saving artifacts...
Running migration: 3_deploy_faucet.js
  Deploying Faucet...
  ... 0x6fbf283bcc97d7c52d92fd91f6ac02d565f5fded483a6a0f824f66edc6fa90c3
  Faucet: 0xb18a42e9468f7f1342fa3c329ec339f254bc7524
Saving artifacts...
```
이제 일부 MET 토큰을 Faucet 컨트랙트에 보내보자  
```
truffle(ganache)> METoken.deployed().then(instance =>
                  { instance.transfer(Faucet.address, 100000) })
truffle(ganache)> METoken.deployed().then(instance =>
                  { instance.balanceOf(Faucet.address).then(console.log)})
truffle(ganache)> BigNumber { s: 1, e: 5, c: [ 100000 ] }
```
1,000 MET 을 Faucet 컨트랙트에 보내졌다. 해당 토큰을 인출하면 어떻게 될까?   
Faucet.sol 은 withdaw 함수 하나만 있고, 이것은 이더만 인출할 수 있음. 따라서 MET 를 인출할 수 있는 함수가 없다.  
인출함수를 호출하면 현재는 이더가 없으므로 실패할 것임  

현재 보내짐 MET ERC20 토큰은 영원히 Faucet 컨트랙트에 잠기게 됨.

## Demonstrating the "approve & transferFrom" workflow
현재 Faucet 컨트랙트는 ERC20 토큰을 핸들링할 수 없으므로 가능하게 수정하자. OpenZeppelin 의존성 설치하고 faucet 컨트랙트를 METFaucet.sol 이라고 새로 이름짓자.  
```
link:code/truffle/METoken_METFaucet/contracts/METFaucet.sol[]
```
새로은 METFaucet 은 transferFrom 함수를 만들었고, 2개의 인자를 갖는다  
아래와 같이 선언해서 사용함 
```
StandardToken public METoken;
address public METOwner;
```
생성자에서 아래와 같이 초기화 한다
```
// METFaucet constructor - provide the address of the METoken contract and
// the owner address we will be approved to transferFrom
function METFaucet(address _METoken, address _METOwner) public {

	// Initialize the METoken from the address provided
	METoken = StandardToken(_METoken);
	METOwner = _METOwner;
}
```
아래와 같이 transferFrom 함수를 사용한다
```
// Use the transferFrom function of METoken
METoken.transferFrom(METOwner, msg.sender, withdraw_amount);
```
마지막으로 실수로 이더를 전송해서 영원히 이더가 정체되는 것을 막고자 fallback 함수를 아래와 같이 수정한다. 따라서 전송되는 이더를 막는다
```
// REJECT any incoming ether
function () external payable { revert(); }
```
아래와 같이 배포 코드를 일부 수정한다.
```
var METoken = artifacts.require("METoken");
var METFaucet = artifacts.require("METFaucet");

module.exports = function(deployer, network, accounts) {

	var owner = accounts[0];
	// Deploy the METoken contract first
	deployer.deploy(METoken, {from: owner}).then(function() {
		// Then deploy METFaucet and pass the address of METoken and the
		// address of the owner of all the MET who will approve METFaucet
		return deployer.deploy(METFaucet, METoken.address, owner);
  	});
}
```
이제 아래와 같이 테스트해보자. METoken 이 배포되었으므로 web3.eth.accounts[0] 가 모든 MET 토큰의 소유자임.  
1,000 MET 를 인출할 수 있도록 승인 함수를 호출하고, web3.eth.accounts[1] 에서 10 MET 를 인출한다.
```
$ truffle console --network ganache
truffle(ganache)> migrate
Using network 'ganache'.

Running migration: 1_initial_migration.js
  Deploying Migrations...
  ... 0x79352b43e18cc46b023a779e9a0d16b30f127bfa40266c02f9871d63c26542c7
  Migrations: 0xaa588d3737b611bafd7bd713445b314bd453a5c8
Saving artifacts...
Running migration: 2_deploy_contracts.js
  Replacing METoken...
  ... 0xc42a57f22cddf95f6f8c19d794c8af3b2491f568b38b96fef15b13b6e8bfff21
  METoken: 0xf204a4ef082f5c04bb89f7d5e6568b796096735a
  Replacing METFaucet...
  ... 0xd9615cae2fa4f1e8a377de87f86162832cf4d31098779e6e00df1ae7f1b7f864
  METFaucet: 0x75c35c980c0d37ef46df04d31a140b65503c0eed
Saving artifacts...
truffle(ganache)> METoken.deployed().then(instance =>
                  { instance.approve(METFaucet.address, 100000) })
truffle(ganache)> METoken.deployed().then(instance =>
                  { instance.balanceOf(web3.eth.accounts[1]).then(console.log) })
truffle(ganache)> BigNumber { s: 1, e: 0, c: [ 0 ] }
truffle(ganache)> METFaucet.deployed().then(instance =>
                  { instance.withdraw(1000, {from:web3.eth.accounts[1]}) })
truffle(ganache)> METoken.deployed().then(instance =>
                  { instance.balanceOf(web3.eth.accounts[1]).then(console.log) })
truffle(ganache)> BigNumber { s: 1, e: 3, c: [ 1000 ] }
```
적합하게 사용된다면 ERC20 토큰이 EOA 와 다른 컨트랙트에서 사용할 수 있다.  


## Issues with ERC20 Tokens
ERC20 토큰 표준의 채택은 정말로 폭발적이었다. 새로운 기능을 실험하고 다양한 "크라우드 펀드" 경매와 ICO에서 자금을 조달하기 위해 수천 개의 토큰이 출시되었습니다. 그러나 계약 주소로 토큰을 전송하는 문제에서 보았듯이 몇 가지 잠재적인 함정이 있습니다.

ERC20 토큰의 덜 명백한 문제 중 하나는 토큰과 에테르 그 자체 사이의 미묘한 차이를 드러낸다는 것이다. 수신자 주소를 대상으로 하는 트랜잭션에 의해 에테르가 전송될 경우 토큰 전송은 특정 토큰 계약 상태 내에서 발생하며 수신자의 주소가 아닌 토큰 계약을 대상으로 합니다. 토큰 계약은 잔액을 추적하고 이벤트를 발행합니다. 토큰 전송에서는 실제로 토큰 수신자에게 트랜잭션이 전송되지 않습니다. 대신 받는 사람의 주소가 토큰 계약 자체 내의 지도에 추가됩니다. 에테르를 주소로 전송하는 트랜잭션은 주소의 상태를 변경합니다. 토큰을 주소로 전송하는 트랜잭션은 받는 사람 주소의 상태가 아니라 토큰 계약의 상태만 변경합니다. ERC20 토큰을 지원하는 지갑도 사용자가 특정 토큰 계약을 '관람'에 명시적으로 추가하지 않는 한 토큰 잔액을 인식하지 못한다. 일부 지갑은 가장 인기 있는 토큰 계약을 시청하여 자신이 통제하는 주소의 잔액을 탐지하지만, 이는 기존 ERC20 계약의 극히 일부에 국한됩니다.

실제로 사용자는 가능한 모든 ERC20 토큰 계약에서 모든 잔액을 추적하기를 원하지 않습니다. 많은 ERC20 토큰은 사용 가능한 토큰보다는 전자 메일 스팸에 더 가깝습니다. 사용자를 유인하기 위해 에테르 활동이 있는 계정에 대한 밸런스를 자동으로 만듭니다. 특히 사전 판매에서 만들어진 Ethereum 주소가 오랜 활동 이력이 있는 경우, 난데없이 나타난 "정크" 토큰으로 가득 찬 것을 발견하게 될 것이다. 물론 주소가 토큰으로 가득 찬 것은 아닙니다. 토큰 계약서에 귀하의 주소가 들어 있습니다. 이러한 토큰 계약은 주소를 보는 데 사용하는 블록 탐색기 또는 지갑에서 감시 중인 경우에만 표시됩니다.

토큰은 에테르와 같은 방식으로 동작하지 않습니다. 에테르는 송신 기능과 함께 전송되며 계약 또는 외부 소유 주소의 지불 기능에 의해 수락됩니다. 토큰은 ERC20 계약에만 존재하는 양도 또는 승인 & 전송 기능을 사용하여 전송되며, (적어도 ERC20에서는) 수취인 계약에서 지불 가능 기능을 트리거하지 않습니다. 토큰은 에테르와 같은 암호 화폐와 같이 기능하도록 되어 있지만, 그들은 그러한 환상을 깨는 특정한 차이점들을 가지고 있다.

다른 문제를 고려하십시오. 에테르를 보내거나 이더리움 계약서를 사용하려면 에테르가 필요합니다. 토큰을 보내려면 에테르도 필요합니다. 당신은 토큰으로 거래의 기름값을 지불할 수 없고 토큰 계약으로 당신을 위한 기름값을 지불할 수 없다. 이는 먼 미래의 어느 시점에서 변경될 수 있지만, 그 사이에 다소 이상한 사용자 경험을 유발할 수 있다. 예를 들어, 일부 비트코인을 토큰으로 변환하기 위해 거래소나 ShapeShift를 사용한다고 가정해 봅시다. 토큰의 계약을 추적하고 잔액을 표시하는 지갑에 토큰을 "수신"합니다. 지갑에 있는 다른 암호 화폐와 동일하게 보입니다. 그래도 토큰을 보내보면 지갑에 에테르가 필요하다는 것을 알 수 있습니다. 당신은 혼란스러울 수 있다. 결국 토큰을 받는 데 에테르가 필요하지 않았다. 에테르가 없는 것 같군요. 토큰이 ERC20 토큰인지도 몰랐을 수도 있고, 자체 블록 체인이 있는 암호 화폐라고 생각했을 수도 있습니다. 환상이 깨졌어요

이러한 문제 중 일부는 ERC20 토큰과 관련이 있습니다. 다른 이슈는 Ethereum 내의 추상화 및 인터페이스 경계와 관련된 보다 일반적인 이슈이다. 토큰 인터페이스를 변경하여 해결할 수 있는 것도 있고, EOA와 계약 간의 차이, 거래와 메시지 간의 차이와 같은 이더리움 내의 기본 구조에 대한 변경이 필요한 것도 있다. 일부는 정확히 "해결 가능"하지 않을 수 있으며 뉘앙스를 숨기고 근본적인 차이와 관계없이 사용자 경험을 일관되게 만들기 위해 사용자 인터페이스 설계가 필요할 수 있다.

다음 섹션에서는 이러한 문제 중 일부를 해결하려는 다양한 제안에 대해 살펴보겠습니다.


# ERC223: A Proposed Token Contract Interface Standard
ERC223 제안은 목적지 주소가 계약인지 여부를 탐지하여 실수로 토큰을 계약(토큰을 지원할 수도 있고 지원하지 않을 수도 있음)으로 전송하는 문제를 해결하려고 시도한다. ERC223에서는 토큰을 수락하도록 설계된 계약이 tokenFallback이라는 함수를 구현해야 합니다. 전송 대상이 계약이고 계약이 토큰에 대한 지원을 가지고 있지 않으면(즉, 토큰 폴백을 구현하지 않음) 전송이 실패합니다.

목적지 주소가 계약인지 여부를 탐지하기 위해 ERC223 참조 구현은 다소 창의적인 방법으로 인라인 바이트코드의 작은 세그먼트를 사용한다.

```
function isContract(address _addr) private view returns (bool is_contract) {
  uint length;
    assembly {
       // retrieve the size of the code on target address; this needs assembly
       length := extcodesize(_addr)
    }
    return (length>0);
}
```
ERC223 컨트랙트 인터페이스 스펙
```
interface ERC223Token {
  uint public totalSupply;
  function balanceOf(address who) public view returns (uint);

  function name() public view returns (string _name);
  function symbol() public view returns (string _symbol);
  function decimals() public view returns (uint8 _decimals);
  function totalSupply() public view returns (uint256 _supply);

  function transfer(address to, uint value) public returns (bool ok);
  function transfer(address to, uint value, bytes data) public returns (bool ok);
  function transfer(address to, uint value, bytes data, string custom_fallback)
      public returns (bool ok);

  event Transfer(address indexed from, address indexed to, uint value,
                 bytes indexed data);
}
```
ERC223은 널리 구현되지 않으며, ERC 논의 스레드에서 계약 인터페이스 수준에서 변경사항 구현과 사용자 인터페이스 간의 절충과 역호환성에 대한 약간의 논쟁이 있다. 논쟁은 계속된다.

# ERC777: A Proposed Token Contract Interface Standard
개선된 토큰 계약 표준을 위한 또 다른 제안은 ERC777이다. 이 제안에는 다음과 같은 몇 가지 목표가 있습니다.

+ ERC20 호환 인터페이스를 제공  
+ 전송 함수를 사용하여 토큰을 전송하는 방법(이더 전송과 유사)  
+ 토큰 계약 등록을 위해 ERC820과 호환    
+ 계약 및 주소가 토큰을 통해 보내는 토큰을 제어하도록 허용하려면 전송하기 전에 호출되는 토큰 전송 기능  
+ 받는 사람의 토큰 수신 함수를 호출하여 계약 및 주소에 토큰 수신을 통지하고 계약에서 받는 토큰 함수를 제공하도록 요구하여 토큰이 계약에 잠길 확률을 줄이려면  
+ 기존 계약에서 토큰에 대한 프록시 계약을 사용하도록 허용하려면보내기 및 토큰수신함수  
+ 계약 또는 EOA에 보내는 것과 동일한 방식으로 작동  
+ 토큰을 만들고 굽기 위한 특정 이벤트를 제공  
+ 운영자(신뢰할 수 있는 타사, 확인된 계약)가 토큰 보유자를 대신하여 토큰을 이동할 수 있도록 함  
+ 토큰 전송 트랜잭션에 대한 메타데이터를 userData 및 operatorData 필드에 제공하려면 다음과 같이 하십시오.  

ERC777에 대한 진행 중인 논의는 GitHub에서 찾을 수 있다.  
ERC777 계약 인터페이스 규격은 다음과 같다.  
```
interface ERC777Token {
    function name() public constant returns (string);
    function symbol() public constant returns (string);
    function totalSupply() public constant returns (uint256);
    function granularity() public constant returns (uint256);
    function balanceOf(address owner) public constant returns (uint256);

    function send(address to, uint256 amount, bytes userData) public;

    function authorizeOperator(address operator) public;
    function revokeOperator(address operator) public;
    function isOperatorFor(address operator, address tokenHolder)
        public constant returns (bool);
    function operatorSend(address from, address to, uint256 amount,
                          bytes userData,bytes operatorData) public;

    event Sent(address indexed operator, address indexed from,
               address indexed to, uint256 amount, bytes userData,
               bytes operatorData);
    event Minted(address indexed operator, address indexed to,
                 uint256 amount, bytes operatorData);
    event Burned(address indexed operator, address indexed from,
                 uint256 amount, bytes userData, bytes operatorData);
    event AuthorizedOperator(address indexed operator,
                             address indexed tokenHolder);
    event RevokedOperator(address indexed operator, address indexed tokenHolder);
}
```


## ERC777 hooks
ERC777 토큰 송신자 훅 규격
```
interface ERC777TokensSender {
    function tokensToSend(address operator, address from, address to,
                          uint value, bytes userData, bytes operatorData) public;
}
```
이 인터페이스의 구현은 어느 주소의 통보 하기 위해, 또는 토큰의 직불을 막기 위해 처리하기 위해 필요하다.를 계약 이 인터페이스를 구현하는 주소 ERC820을 통해, 그 계약 자체 또는 다른 주소에 대한 인터페이스를 구현하는 등록해야 한다.  

ERC777 토큰 수령자 훅 규격  
```
interface ERC777TokensRecipient {
  function tokensReceived(
     address operator, address from, address to,
    uint amount, bytes userData, bytes operatorData
  ) public;
}
```
이 인터페이스의 구현은 토큰 수신을 통지받거나 처리하거나 거부하려는 주소에 필요합니다. 토큰 수신인에게는 토큰 발신인 인터페이스와 동일한 논리와 요구 사항이 적용되며, 토큰 잠금을 방지하기 위해 수신인 계약이 이 인터페이스를 구현해야 한다는 제약 조건이 추가됩니다. 수취인 계약이 이 인터페이스를 구현하는 주소를 등록하지 않으면 토큰 전송이 실패합니다.

중요한 점은 주소당 토큰 보낸 사람과 토큰 받는 사람을 각각 하나씩만 등록할 수 있다는 것입니다. 따라서 ERC777 토큰 전송마다 동일한 후크 기능이 ERC777 토큰 전송의 직불 및 수신 시 호출된다. 특정 토큰은 특정 사용 사례를 처리하기 위해 특정 토큰 계약 주소인 메시지의 보낸 사람을 사용하여 이러한 기능에서 식별할 수 있습니다.

한편, 동일한 토큰 송신자 및 토큰 수신자 후크를 여러 주소에 등록할 수 있으며 후크는 발신자 및 수신자 매개 변수를 사용하여 발신자와 대상 수신자를 구별할 수 있습니다.

ERC777의 참조 구현은 제안서에 연계되어 있다. ERC777은 ERC820에 명시된 레지스트리 계약에 대한 병렬 제안에 따라 달라진다. ERC777에 대한 논쟁 중 일부는 두 가지 큰 변화를 동시에 채택하는 복잡성에 관한 것이다: 새로운 토큰 표준과 레지스트리 표준. 토론은 계속된다.


# ERC721: Non-fungible Token (Deed) Standard
지금까지 살펴본 모든 토큰 표준은 곰팡이가 있는 토큰에 대한 것으로, 토큰의 단위는 서로 교환할 수 있다는 것을 의미합니다. ERC20 토큰 표준은 각 계정의 최종 잔액만 추적하며 토큰의 출처를 (명시적으로) 추적하지 않습니다.

ERC721 제안은 액티비 토큰(행위로도 알려져 있음)에 대한 표준입니다.

옥스포드 사전정의로:  
| 증서: 서명 및 인도된 법률 문서, 특히 재산 또는 법적 권리의 소유에 관한 문서.   

"위임"이라는 단어의 사용은 "재산 소유권" 부분을 반영하기 위한 것이지만, 아직 어떤 사법권에서도 "법적 문서"로 인정되지 않는다. 향후 어느 시점에선가 블록 체인 플랫폼의 디지털 서명을 기반으로 한 법적 소유권이 합법적으로 인정될 가능성이 높다.

불법 토큰은 고유한 물건의 소유권을 추적합니다. 소유되는 것은 게임 내 아이템이나 디지털 수집품과 같은 디지털 아이템일 수도 있고, 또는 집, 자동차 또는 예술품과 같은 토큰에 의해 소유권이 추적되는 물리적 아이템일 수도 있습니다. 행위들은 또한 대출, 부채, 완화 등과 같이 부정적인 가치를 지닌 것들을 나타낼 수 있다. ERC721 표준은 증서에 의해 소유권이 추적되는 물건의 성격에 제한이나 기대를 두지 않으며, 이 표준의 경우 256비트 식별자에 의해 달성되는 고유 식별만 요구한다.  

표준과 논의의 세부사항은 두 개의 GitHub 위치에서 추적된다.  

+ 초기 제안  
+ 지속 논의  

ERC20과 ERC721의 기본적인 차이를 파악하려면 ERC721에 사용된 내부 데이터 구조를 살펴보는 것으로 충분하다.  
```
// Mapping from deed ID to owner
mapping (uint256 => address) private deedOwner;
```
ERC20은 소유자가 매핑의 기본 키인 각 소유자의 잔액을 추적하는 반면, ERC721은 매핑의 기본 키인 증서 ID와 소유자를 추적한다. 이 기본 차이 흐름에서 비결합 토큰의 모든 속성이 흐릅니다.  

ERC721 계약 인터페이스 사양은 다음과 같다.  
```
interface ERC721 /* is ERC165 */ {
    event Transfer(address indexed _from, address indexed _to, uint256 _deedId);
    event Approval(address indexed _owner, address indexed _approved,
                   uint256 _deedId);
    event ApprovalForAll(address indexed _owner, address indexed _operator,
                         bool _approved);

    function balanceOf(address _owner) external view returns (uint256 _balance);
    function ownerOf(uint256 _deedId) external view returns (address _owner);
    function transfer(address _to, uint256 _deedId) external payable;
    function transferFrom(address _from, address _to, uint256 _deedId)
        external payable;
    function approve(address _approved, uint256 _deedId) external payable;
    function setApprovalForAll(address _operator, boolean _approved) payable;
    function supportsInterface(bytes4 interfaceID) external view returns (bool);
}
```

ERC721은 또한 두 개의 선택적 인터페이스(메타데이터용 인터페이스와 행위 및 소유자의 열거용 인터페이스)를 지원합니다.  

메타데이터를 위한 ERC721 옵션 인터페이스는 다음과 같습니다.
```
interface ERC721Metadata /* is ERC721 */ {
    function name() external pure returns (string _name);
    function symbol() external pure returns (string _symbol);
    function deedUri(uint256 _deedId) external view returns (string _deedUri);
}
```
열거를 위한 ERC721 옵션 인터페이스는 다음과 같습니다.
```
interface ERC721Enumerable /* is ERC721 */ {
    function totalSupply() external view returns (uint256 _count);
    function deedByIndex(uint256 _index) external view returns (uint256 _deedId);
    function countOfOwners() external view returns (uint256 _count);
    function ownerByIndex(uint256 _index) external view returns (address _owner);
    function deedOfOwnerByIndex(address _owner, uint256 _index) external view
        returns (uint256 _deedId);
}
```

# Using Token Standards
이전 섹션에서는 토큰 계약에 대해 제안된 여러 표준과 널리 배치된 몇 가지 표준을 검토했습니다. 이 표준들은 정확히 무엇을 하는가? 이 기준을 사용해야 합니까? 그것들을 어떻게 사용해야 할까요? 이러한 표준 이상의 기능을 추가해야 합니까? 어떤 기준을 사용해야 합니까? 우리는 그 질문들 중 일부를 다음에 검토할 것이다.


### 토큰 표준이 무엇인가? 그들의 목적은 무엇인가?
토큰 표준은 구현을 위한 최소 사양입니다. 즉, ERC20을 준수하기 위해서는 ERC20 표준에 명시된 기능과 동작을 최소한 구현해야 합니다. 또한 표준에 속하지 않는 함수를 구현하여 기능에 자유롭게 추가할 수 있습니다.

이러한 표준의 주된 목적은 계약 간의 상호운용성을 장려하는 것이다. 그러므로, 모든 지갑, 교환, 사용자 인터페이스 및 기타 인프라 요소들은 규격에 따르는 계약과 예측 가능한 방식으로 접속할 수 있다. 즉, ERC20 표준을 따르는 계약을 구축하면 모든 기존 지갑 사용자가 지갑 업그레이드나 노력 없이 토큰 거래를 원활하게 시작할 수 있습니다.

표준은 규범적인 것이 아니라 기술적인 것이다. 이러한 기능을 어떻게 구현하느냐는 계약의 내부 기능은 표준과 관련이 없습니다. 그들은 특정한 상황에서 행동을 통제하는 몇 가지 기능적 요구사항을 가지고 있지만, 그들은 구현을 규정하지는 않는다. 이것의 예는 값이 0으로 설정된 경우 전송함수의 동작이다.


















