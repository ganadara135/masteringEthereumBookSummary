# Oracles
오라클은 이더리움 스마트컨트랙트에게 외부 데이터 소스를 제공할 수 있는 시스템임  
오라클이라는 용어는 그리스 신화로부터 유래했고, 미래를 볼 수 있는 신과 대화할 수 있는 사람을 의미함  
블록체인의 문맥에서는 오라클은 이더리움 외부에 있는 질문에 답할 수 있는 시스템임  
이상적으로 오라클은 신뢰가 필요없는 시스템임  
즉, 분산 원리로 작동하므로 신뢰가 굳이 필요없는 것을 의미함  

이 장에서는  Ethereum smart contracts에 외부 데이터 소스를 제공할 수 있는 시스템인 oracles 에 대해 설명 합니다.  
블록체인의 맥락에서 오라클은 이더리움 외부의 질문에 답할 수 있는 시스템이다.   
이상적으로는 무신뢰 시스템으로 분산된 원리로 운영되기 때문에 신뢰받을 필요가 없다는 뜻이다.  

# Why Oracles Are Needed
이더리움 플랫폼의 핵심 구성 요소는 이더리움 가상 머신으로, 분산 네트워크의 모든 노드에서 합의 규칙에 따라 프로그램을 실행하고 이더리움 상태를 업데이트할 수 있습니다.   
합의를 유지하기 위해 EVM 실행은 완전히 결정적이어야 하며 Ethereum 상태 및 서명된 트랜잭션의 공유 컨텍스트에만 기반해야 합니다.   
이것은 특히 두 가지 중요한 결과를 가지고 있다. 첫째는 EVM과 스마트 계약이 함께 작동하는 무작위성의 본질적인 소스가 있을 수 없다는 것입니다.   
두 번째는 외부 데이터가 트랜잭션의 데이터 페이로드로만 도입될 수 있다는 것입니다.  
스마트 계약에 무작위성을 제공하기 위해 EVM에서 진정한 무작위 기능의 금지를 이해하려면 이러한 기능을 실행한 후 합의를 달성하려는 시도에 미치는 영향을 고려하십시오.  
노드 A는 스마트 계약을 대신하여 명령을 실행하고 3을 저장합니다.   
동일한 스마트 계약을 실행하는 노드 B는 대신 7을 저장합니다. 따라서 노드 A와 B는 동일한 컨텍스트에서 정확히 동일한 코드를 실행했음에도 불구하고 결과 상태가 어떠해야 하는지에 대해 서로 다른 결론에 도달하게 됩니다.   
실제로 스마트 계약이 평가될 때마다 다른 결과 상태가 달성될 수 있습니다.   
따라서 다수의 노드가 전 세계에서 독립적으로 운영되는 네트워크는 결과 상태가 무엇이 되어야 하는지에 대해 분권화된 합의에 도달할 수 있는 방법은 없을 것이다.   
실제로는 에테르 전송을 포함한 연쇄 효과가 기하급수적으로 증가하기 때문에 이 예보다 훨씬 더 빨리 악화될 것입니다.
암호학적으로 안전한 해시 함수(결정적이므로 EVM의 일부일 수 있고 실제로 포함됨)와 같은 의사 난수 함수는 많은 응용 프로그램에 충분하지 않습니다.  
앞면 또는 뒷면을 무작위로 선택해야 하는 동전 던지기를 예로 들어 보겠습니다.   
광부는 게임을 플레이하고 승리할 블록에 거래만 포함함으로써 이점을 얻을 수 있습니다.   
이 문제를 해결하려면 어떻게 해야 합니까? 모든 노드가 서명된 트랜잭션의 내용에 동의할 수 있으므로 임의의 출처, 가격 정보, 일기 예보 등을 포함한 외부 정보가 네트워크로 전송되는 트랜잭션의 데이터 부분으로 도입될 수 있습니다.   
그러나 이러한 데이터는 확인할 수 없는 출처에서 나온 것이기 때문에 단순히 신뢰할 수 없습니다.   
이 장의 나머지에 우리는 세부에서 논의할 것이다 이런 문제점들을 해결 하려고 시도하는 것은 oracles을 사용한다

# Oracle Use Cases and Examples
오라클스는 이상적으로는 미식축구 경기의 결과, 금 가격 또는 진정한 무작위와 같은 외부정보(즉, "실제 세계" 또는 오프체인) 를 스마트 계약이 사용할 수 있도록 이더리움 플랫폼에 제공하는(또는 최소한 신뢰성이 거의 없는) 방법을 제공한다.   
또한 DApp 프런트엔드에 직접 데이터를 안전하게 릴레이하는 데 사용할 수도 있습니다.     
따라서 오라클은 오프체인 세계와 스마트 계약 간의 격차를 메우기 위한 메커니즘으로 생각할 수 있습니다.   
스마트 계약이 실제 이벤트 및 데이터를 기반으로 계약 관계를 시행할 수 있도록 하면 범위가 크게 확장됩니다.   
그러나 이것은 Ethereum의 보안 모델에 외부 위험을 초래할 수도 있습니다.   
사람이 사망할 때 자산을 분배하는 "스마트 윌" 계약을 고려하십시오.  
이것은 스마트 계약 공간에서 자주 논의되는 것입니다. 신뢰할 수 있는 오라클의 위험을 강조합니다.    
이런 계약으로 지배하는 상속금액이 충분히 많다면 소유주가 죽기 전에 신탁을 해킹해 자산의 분배를 촉발할 유인이 매우 높다
일부 오라클은 학업 인증서 또는 정부 ID와 같은 특정 개인 데이터 소스에 특정한 데이터를 제공합니다.   
대학이나 정부 부서와 같은 이러한 데이터의 출처는 완전히 신뢰할 수 있으며 데이터의 진실성은 주관적입니다(진리는 출처의 권위에 대한 호소에 의해서만 결정됨).   
따라서 이러한 데이터는 독립적으로 검증할 수 있는 객관적인 진실이 없기 때문에 신뢰할 수 없는(즉, 출처를 신뢰하지 않고) 제공될 수 없습니다.   
따라서 스마트 계약을 위한 데이터 브리지도 제공하기 때문에 "오라클"로 간주되는 정의에 이러한 데이터 소스를 포함합니다.   
그들이 제공하는 데이터는 일반적으로 여권이나 성취 기록과 같은 증명의 형태를 취합니다.   
증명은 미래에 블록체인 플랫폼의 성공에 큰 부분이 될 것이며,

오라클에서 제공할 수 있는 데이터의 몇 가지 예는 다음과 같습니다.  
•	양자/열 프로세스와 같은 물리적 소스의 난수/엔트로피: 예: 복권 스마트 계약에서 승자를 공정하게 선택하기 위해
•	자연 재해에 색인된 매개변수 트리거: 예: 지진 채권에 대한 리히터 규모 측정과 같은 재난 채권 스마트 계약 트리거
•	환율 데이터: 예를 들어 암호화폐를 법정 화폐로 정확하게 연결하기 위해
•	자본 시장 데이터: 예: 토큰화된 자산/증권의 가격 바구니
•	벤치마크 참조 데이터: 예: 이자율을 스마트 금융 파생상품에 통합
•	정적/유사 정적 데이터: 보안 식별자, 국가 코드, 통화 코드 등
•	시간 및 간격 데이터: 정확한 시간 측정에 기반한 이벤트 트리거용
•	날씨 데이터: 예: 일기 예보를 기반으로 한 보험료 계산
•	정치 이벤트: 예측 시장 해결을 위해
•	스포츠 이벤트: 예측 시장 해결 및 판타지 스포츠 계약
•	지리적 위치 데이터: 예: 공급망 추적에 사용
•	손상 확인: 보험 계약용
•	다른 블록체인에서 발생하는 이벤트: 상호 운용성 기능
•	이더 시장 가격: 예: 법정 가스 가격 오라클의 경우
•	항공편 통계: 예: 그룹 및 클럽에서 항공권 풀링을 위해 사용  

다음 섹션에서는 기본 오라클 패턴, 계산 오라클, 탈중앙화 오라클, 그리고 솔리디티의 오라클 클라이언트 구현을 포함하여 오라클이 구현될 수 있는 몇 가지 방법을 검토할 것입니다.  

# Oracle Design Patterns
모든 오라클은 정의에 따라 몇 가지 주요 기능을 제공합니다.   
여기에는 다음과 같은 기능이 포함됩니다.
•	오프체인 소스에서 데이터를 수집합니다.
•	서명된 메시지로 데이터를 온체인으로 전송합니다.
•	데이터를 스마트 계약의 저장소에 넣어 사용할 수 있도록 합니다.
스마트 계약의 저장소에서 데이터를 사용할 수 있게 되면 오라클 스마트 계약의 "검색" 기능을 호출하는 메시지 호출을 통해 다른 스마트 계약에서 데이터에 액세스할 수 있습니다.   
또한 이더리움 노드 또는 네트워크 지원 클라이언트에서 오라클의 스토리지를 "조사"하여 직접 액세스할 수도 있습니다.  
Oracle을 설정하는 세 가지 주요 방법은 요청-응답 , 게시-구독 및 즉시 읽기 로 분류할 수 있습니다 .  
가장 간단하고 즉시 읽히는 말로 시작하는 것은 "ethereumbook.info의 주소가 무엇인가?" 또는 "이 사람은 18세 이상인가?"와 같이 즉각적인 결정을 위해 필요한 데이터만 제공하는 것이다.   
이러한 종류의 데이터를 쿼리하려는 사람들은 "적시" 기반으로 쿼리를 수행하는 경향이 있습니다.   
  조회는 정보가 필요할 때 수행되며 다시는 없을 수도 있습니다. 이러한 오라클에는 학술 인증서, 다이얼 코드, 기관 멤버십, 공항 식별자, 주권ID 등과 같은 조직에 대한 데이터를 보유하거나 발행한 오라클이 포함됩니다.  
이러한 유형의 Oracle은 계약 저장소에 데이터를 한 번 저장하며, 다른 스마트 계약은 Oracle 계약에 대한 요청 호출을 사용하여 데이터를 검색할 수 있다. 그것은 업데이트 될 수도 있다.
오라클의 저장소에 있는 데이터도 Palaver를 거치지 않고 블록체인이 가능한 애플리케이션(즉, Ethereum 클라이언트 연결)에 의해 직접 조회할 수 있으며, 거래의 발생에 따른 가스 비용을 부담하지 않는다.  
술을 구매하려는 고객의 나이를 확인하려는 가게는 이런 방식으로 오라클을 사용할 수 있다.   
  이러한 유형의 오라클은 이러한 데이터 요청에 응답하기 위해 서버를 실행하고 유지해야 하는 조직이나 회사에 매력적이다.   
 오라클이 저장한 데이터는 효율성이나 개인 정보 보호 등의 이유로 오라클이 서비스하는 원시 데이터가 아닐 가능성이 높다는 점에 유의하십시오.   
 대학은 과거 학생의 학업성취도 증명서를 위한 신탁을 제정할 수도 있다. 그러나 인증서의 전체 세부사항(수강 과정 및 성적에 따라 달라질 수 있음)을 저장하는 것은 과도할 것이다.   
   대신 인증서의 해시만으로 충분하다.   
 이와 마찬가지로, 정부는 시민 ID를 이더리움 플랫폼에 올려놓고 싶어할 수도 있는데, 이 플랫폼에는 분명히 포함된 세부 사항들이 비공개로 유지될 필요가 있다.   
 다시 말하지만, 데이터를 해싱(좀 더 신중하게, 솔트를 사용하는 Merkle 트리에서)하고 루트 해시를 스마트 계약의 저장소에 저장하는 것만이 그러한 서비스를 조직하는 효율적인 방법이 될 것이다.  
다음 설정은 게시-구독입니다., 여기서 변경될 것으로 예상되는 데이터에 대한 브로드캐스트 서비스를 효과적으로 제공하는 오라클은(아마도 정기적으로 그리고 자주) 스마트 계약에 의해 온체인에 의해 폴링되거나 오프체인 데몬이 업데이트를 감시합니다.   
이 카테고리는 RSS 피드, WebSub 등과 유사한 패턴을 가지고 있습니다. 여기서 오라클은 새로운 정보로 업데이트되고 플래그는 스스로 "구독"이라고 생각하는 사람들이 새 데이터를 사용할 수 있음을 나타냅니다.   
이해 관계자는 오라클을 폴링하여 최신 정보가 변경되었는지 확인하거나 오라클 계약에 대한 업데이트를 듣고 발생 시 조치를 취해야 합니다.   
예를 들면 가격 피드, 날씨 정보, 경제 또는 사회 통계, 교통 데이터 등이 있습니다.   
폴링은 웹 서버의 세계에서 매우 비효율적이지만 블록체인 플랫폼의 P2P 컨텍스트에서는 그렇지 않습니다.   
이더리움 클라이언트는 계약 저장소 변경을 포함하여 모든 상태 변경을 따라야 하므로 데이터 변경 폴링은 동기화된 클라이언트에 대한 로컬 호출입니다.   
Ethereum 이벤트 로그를 사용하면 애플리케이션에서 Oracle 업데이트를 쉽게 찾을 수 있으므로 이 패턴은 어떤 면에서는 "푸시" 서비스로 간주될 수도 있습니다.   
그러나 일부 분산 응용 프로그램에 필요할 수 있는 스마트 계약에서 폴링이 수행되는 경우(예: 활성화 인센티브가 불가능한 경우) 상당한 가스 비용이 발생할 수 있습니다.   
요청 - 응답범주가 가장 복잡합니다.   
데이터 공간이 너무 커서 스마트 계약에 저장하기 어렵고 사용자가 한 번에 전체 데이터 세트의 작은 부분만 필요로 하는 경우입니다.   
데이터 공급자 비즈니스에도 적용 가능한 모델입니다.   
실용적인 측면에서 이러한 오라클은 요청을 모니터링하고 데이터를 검색 및 반환하는 데 사용되는 온체인 스마트 계약 및 오프체인 인프라 시스템으로 구현될 수 있습니다.   
  분산 응용 프로그램의 데이터 요청은 일반적으로 여러 단계를 포함하는 비동기식 프로세스입니다. 이 패턴에서 먼저 EOA는 분산 응용 프로그램과 거래하여 Oracle 스마트 계약에 정의된 기능과 상호 작용합니다.   
이 함수는 오라클에 대한 요청을 시작합니다.  
콜백 함수 및 일정 매개변수를 포함할 수 있는 추가 정보 외에 요청된 데이터를 자세히 설명하는 관련 인수와 함께.   
이 트랜잭션이 검증되면 오라클 요청은 오라클 계약에서 발생하는 EVM 이벤트 또는 상태 변경으로 관찰될 수 있습니다.   
인수를 검색하여 오프체인 데이터 소스의 실제 쿼리를 수행하는 데 사용할 수 있습니다.   
 오라클은 또한 요청 처리에 대한 지불, 콜백에 대한 가스 지불 및 요청된 데이터에 액세스할 수 있는 권한을 요구할 수 있습니다.   
마지막으로 결과 데이터는 주어진 시간에 데이터의 유효성을 증명하는 오라클 소유자에 의해 서명되고 직접 또는 오라클 계약을 통해 요청을 한 분산 응용 프로그램에 트랜잭션으로 전달됩니다.   
일정 매개변수에 따라,  
요청-응답 오라클의 단계는 다음과 같이 요약될 수 있습니다.  
1.	DApp에서 쿼리를 받습니다.
2.	쿼리를 구문 분석합니다.
3.	결제 및 데이터 접근 권한이 부여되었는지 확인하세요.
4.	오프체인 소스에서 관련 데이터를 검색하고 필요한 경우 암호화합니다.
5.	포함된 데이터로 트랜잭션에 서명합니다.
6.	트랜잭션을 네트워크에 브로드캐스트합니다.
7.	알림 등 추가로 필요한 트랜잭션을 예약합니다.

다양한 다른 계획도 가능합니다. 예를 들어 EOA에서 직접 데이터를 요청하고 반환할 수 있으므로 Oracle 스마트 계약이 필요하지 않습니다.   
마찬가지로 사물 인터넷 지원 하드웨어 센서에서 요청 및 응답이 이루어질 수 있습니다. 따라서 오라클은 인간, 소프트웨어 또는 하드웨어가 될 수 있습니다.  
여기에 설명된 요청-응답 패턴은 일반적으로 클라이언트-서버 아키텍처에서 볼 수 있습니다.   
이것은 응용 프로그램이 양방향 대화를 할 수 있도록 하는 유용한 메시징 패턴이지만 특정 조건에서는 부적절할 수 있습니다.   
예를 들어, 오라클의 이자율을 요구하는 스마트 채권은 이자율이 항상 정확한지 확인하기 위해 요청-응답 패턴에 따라 매일 데이터를 요청해야 할 수 있습니다.   
이자율이 자주 변경되지 않는다는 점을 감안할 때 발행-구독 패턴이 여기에 더 적합할 수 있습니다. 특히 이더리움의 제한된 대역폭을 고려할 때 그렇습니다.    
게시-구독은 발행자(이 컨텍스트에서 오라클)가 메시지를 수신자에게 직접 보내지 않고 발행된 메시지를 별개의 클래스로 분류하는 패턴입니다.   
구독자는 하나 이상의 클래스에 관심을 표시하고 관심 있는 메시지만 검색할 수 있습니다.   
  이러한 패턴에서 오라클은 이자율이 변경될 때마다 자체 내부 저장소에 이자율을 기록할 수 있습니다.   
구독한 여러 DApp이 Oracle 계약에서 간단히 읽을 수 있으므로 스토리지 비용을 최소화하면서 네트워크 대역폭에 대한 영향을 줄일 수 있습니다.  
브로드캐스트 또는 멀티캐스트 패턴에서 오라클은 모든 메시지를 채널에 게시하고 구독 계약은 다양한 구독 모드에서 채널을 수신합니다.   
예를 들어, 오라클은 암호화폐 환율 채널에 메시지를 게시할 수 있습니다.   
예를 들어 이동 평균 계산을 위해 시계열이 필요한 경우 구독 스마트 계약은 채널의 전체 콘텐츠를 요청할 수 있습니다.   
다른 하나는 현물 가격 계산을 위해 최신 요율만 요구할 수 있습니다.   
오라클이 구독 계약 의 ID를 알 필요가 없는 경우 브로드캐스트 패턴이 적합합니다.  

# Data Authentication
DApp에 의해 쿼리되는 데이터의 출처가 권위적이고 신뢰할 수 있다고 가정할 경우(중요하지 않은 가정), 미결된 의문이 남는다.   
신탁과 요청-응답 메커니즘이 구별되는 실체에 의해 작동될 수 있다는 점을 고려할 때, 우리는 이 메커니즘을 어떻게 신뢰할 수 있는가? 전송 중에 데이터가 변조될 가능성이 뚜렷하기 때문에, 반환된 데이터의 무결성을 증명할 수 있는 오프체인 방법이 중요하다.   
데이터 인증에 대한 두 가지 일반적인 접근방식은 진정성 증명과 신뢰할 수 있는 실행 환경(TE)이다.
진위 증명서는 데이터가 변조되지 않은 암호보증을 말한다. 다양한 증명 기법(예: 디지털 서명 증명)에 기초하여, 그들은 데이터 통신사에서 증명자(즉, 증명 제공자)로 신뢰를 효과적으로 이동시킨다.   
스마트 컨트랙트는 온체인(on-chain)으로 진위여부를 검증해 운용하기 전에 데이터의 무결성을 검증할 수 있다.   
Oraclize는 다양한 진위 증명을 활용하는 오라클 서비스의 예다.   
현재 이더리움 메인 네트워크에서 데이터 쿼리에 사용할 수 있는 그러한 증명 중 하나는 TLSNotary 증명이다.  
TLSNotary 증명을 통해 클라이언트는 클라이언트와 서버 간에 HTTPS 웹 트래픽이 발생했다는 증거를 제3자에게 제공할 수 있다. HTTPS 자체는 안전하지만 데이터 서명은 지원하지 않는다.   
결과적으로, TLSNotary 증명들은 (PageSigner를 통한) TLSNotary 서명에 의존한다.    
  TLSNotary 증명은 TLS(전송 계층 보안) 프로토콜을 활용하여 데이터에 액세스한 후 서명하는 TLS 마스터 키를 서버(oracle), 피감사자(Oraclize) 및 감사자  등 3자 간에 분할할 수 있다. . Oraclize는 Amazon Web Services(AWS) 가상 머신 인스턴스를 감사자로 사용합니다. 인스턴스화 이후 수정되지 않은 것으로 확인할 수 있습니다.   
이 AWS 인스턴스는 TLSNotary 암호를 저장하여 정직성 증명을 제공할 수 있습니다.     
  순수한 요청-응답 메커니즘보다 데이터 변조에 대해 더 높은 보장을 제공하지만 이 접근 방식에서는 Amazon 자체가 VM 인스턴스를 변조하지 않는다는 가정이 필요합니다.  
TEE 접근방식에 기초한 인증된 데이터 피드 Oracle 시스템으로, 이러한 방법은 하드웨어 기반의 안전한 거주지를 활용하여 데이터 무결성을 보장한다.   
Town Crier는 Intel의 SGX(Software Guard eXtensions)를 사용하여 HTTPS 쿼리의 응답이 진짜인지 확인할 수 있도록 한다. SGX는 무결성 보증을 제공하여, 밀폐 구역 내에서 실행 중인 애플리케이션이 다른 프로세스에 의한 변조로부터 CPU에 의해 보호되도록 보장한다. 그것은 또한 기밀성을 제공하며, 동봉된 범위 내에서 실행될 때 응용 프로그램의 상태가 다른 프로세스에 불투명함을 보장한다.  
마지막으로, SGX는 빌드의 해시에 의해 안전하게 식별된 응용프로그램이 실제로 엔클로저 내에서 실행 중이라는 디지털 서명된 증거를 생성함으로써 증명할 수 있다.   
  이 디지털 서명을 확인함으로써, 분산형 애플리케이션은 SGX 영역 내에서 타운 크리에어 인스턴스가 안전하게 실행되고 있음을 증명할 수 있다. 이는 결과적으로 해당 인스턴스가 변조되지 않았으며, 따라서 Town Crier가내보낸 데이터가 진짜라는 것을 증명한다.   
기밀성 속성은 또한 Town Crier의 공개 키를 사용하여 데이터 쿼리를 암호화할 수 있도록 허용함으로써 Town Crier가 개인 데이터를 처리할 수 있게 한다.   
SGX와 같은 범위 내에서 오라클의 쿼리/응답 메커니즘을 작동하면 요청된 데이터가 변경되지 않고 반환되도록(Intel/SGX를 신뢰한다고 가정할 때) 신뢰할 수 있는 타사 하드웨어에서 안전하게 실행되는 것으로 생각할 수 있다.  

# Computation Oracles
지금까지 우리는 데이터를 요청하고 전달하는 맥락에서 오라클에 대해서만 논의했습니다.   
그러나 오라클은 이더리움 고유의 블록 가스 제한과 비교적 비싼 계산 비용을 고려할 때 특히 유용할 수 있는 기능인 임의 계산을 수행하는 데 사용할 수도 있습니다.   
쿼리 결과를 전달하는 것보다 계산 오라클을 사용하여 입력 집합에 대한 계산을 수행하고 온체인 계산이 불가능했을 수 있는 계산된 결과를 반환할 수 있습니다.   
예를 들어, 채권 계약의 수익률을 추정하기 위해 계산 오라클을 사용하여 계산 집약적인 회귀 계산을 수행할 수 있습니다.  
중앙 집중식이지만 감사 가능한 서비스를 기꺼이 신뢰한다면 Oraclize로 다시 갈 수 있습니다.  
분산형 애플리케이션이 샌드박스 처리된 AWS 가상 머신에서 수행된 계산의 출력을 요청할 수 있는 서비스를 제공합니다.  
AWS 인스턴스는 IPFS(Inter-Planetary File System)에 업로드되는 아카이브에 포장된 사용자 구성 Dockerfile에서 실행 가능한 컨테이너를 생성합니다.  
요청 시 Oraclize는 해시를 사용하여 이 아카이브를 검색한 다음 AWS에서 Docker 컨테이너를 초기화하고 실행하여 애플리케이션에 환경 변수로 제공되는 인수를 전달합니다.   
 컨테이너화된 애플리케이션은 시간 제약 조건에 따라 계산을 수행하고 결과를 표준 출력에 기록합니다.   
이 결과는 Oraclize에서 검색하여 분산 애플리케이션으로 반환할 수 있습니다.   
    Oraclize는 현재 감사 가능한 t2.micro AWS 인스턴스에서 이 서비스를 제공하므로 계산이 중요하지 않은 경우 올바른 Docker 컨테이너가 실행되었는지 확인할 수 있습니다.   
그럼에도 불구하고 이것은 진정한 탈중앙화 솔루션이 아닙니다.
검증 가능한 Oracle 사실에 대한 표준으로서 'cryptlet'의 개념은 Microsoft의 광범위한 ESC 프레임워크의 일부로 공식화되었습니다. Cryptlet은 I/O와 같은 인프라를 추상화하는 암호화된 캡슐 내에서 실행되고 CryptoDelegate가 첨부되어 수신 및 발신 메시지가 자동으로 서명, 검증 및 입증됩니다. Cryptlet은 계약 로직이 ACID 방식으로 복잡한 다단계, 다중 블록체인 및 외부 시스템 트랜잭션을 수행할 수 있도록 분산 트랜잭션을 지원합니다.   
이를 통해 개발자는 스마트 계약에 사용할 수 있는 휴대 가능하고 격리된 비공개 해결 방법을 만들 수 있습니다.   
Cryptlet은 여기에 표시된 형식을 따릅니다.
```
public class SampleContractCryptlet : Cryptlet
  {
        public SampleContractCryptlet(Guid id, Guid bindingId, string name,
            string address, IContainerServices hostContainer, bool contract)
            : base(id, bindingId, name, address, hostContainer, contract)
        {
            MessageApi = new CryptletMessageApi(GetType().FullName,
                new SampleContractConstructor())
                
```
보다 분산된 솔루션을 위해 TrueBit으로 전환할 수 있습니다., 확장 가능하고 검증 가능한 오프체인 계산을 위한 솔루션을 제공합니다.   
그들은 각각 계산을 수행하고 해당 계산의 검증을 수행하도록 장려되는 솔버 및 검증 시스템을 사용합니다.   
솔루션에 문제가 있는 경우 계산의 하위 집합에 대한 반복적인 검증 프로세스가 체인 내에서 수행됩니다. 이는 일종의 '검증 게임'입니다. 게임은 일련의 라운드를 통해 진행되며, 각 라운드는 계산의 점점 더 작은 하위 집합을 재귀적으로 확인합니다.   
게임은 결국 최종 라운드에 도달합니다. 여기서 도전은 충분히 사소하여 심사위원(Ethereum 채굴자)이 도전이 충족되었는지 여부에 대해 온체인에서 최종 결정을 내릴 수 있습니다.   
실제로 TrueBit은 계산 시장의 구현이며, 분산 응용 프로그램이 네트워크 외부에서 수행되는 검증 가능한 계산 비용을 지불하도록 허용하지만 검증 게임의 규칙을 시행하기 위해 이더리움에 의존합니다.   
이론적으로 이는 무신뢰 스마트 계약이 모든 계산 작업을 안전하게 수행할 수 있도록 합니다.  
기계 학습에서 작업 증명 검증에 이르기까지 TrueBit과 같은 시스템에는 광범위한 응용 프로그램이 있습니다.   
후자의 예로는 TrueBit을 사용하여 Dogecoin의 작업 증명(Scrypt)을 확인하는 Doge-Ethereum 브리지가 있습니다.   
TrueBit에서 이 검증을 수행함으로써 Ethereum의 Rinkeby 테스트넷에서 스마트 계약 내에서 Dogecoin 거래를 안전하게 검증할 수 있었습니다  

# Decentralized Oracles
중앙 집중식 데이터나 연산 경로는 많은 애플리케이션에 충분하지만, 그것들은 이더리움 네트워크에서 단일 장애 지점을 나타낸다.  
데이터 가용성을 보장하고 온체인 데이터 집계 시스템을 갖춘 개별 데이터 제공자의 네트워크를 구축하기 위한 수단으로서 분산형 언어의 개념을 중심으로 여러 가지 계획이 제안되어 왔다.  
체인링크는 평판계약, 주문매칭계약, 통합계약 등 3가지 핵심 스마트 계약과 데이터 제공자의 오프라인 등록으로 구성된 분산형 오라클 네트워크를 제안했다.   
평판 계약은 데이터 제공자의 성과를 추적하기 위해 사용된다.   
평판 계약의 점수는 오프체인 등록부를 채우는 데 사용된다. 주문매칭계약 계약은 평판 계약을 이용하여 입찰자를 선정한다.  
그런 다음 쿼리 매개변수와 필요한 경고 수를 포함하는 서비스 수준 계약을 마무리한다.   
이것은 구매자가 개인과 직접 거래할 필요가 없다는 것을 의미한다.   
통합 계약은 복수의 의견(약속-반복 체계를 사용하여 제출)으로부터 응답을 수집하고, 쿼리의 최종 집합적 결과를 계산합니다.  
이러한 분산 접근 방식의 주요 과제 중 하나는 집계 기능의 공식화입니다.   
ChainLink는 각 오라클 응답에 대해 유효성 점수가 보고되도록 가중 응답 계산을 제안합니다.   
여기에서 '무효' 점수를 감지하는 것은 중요하지 않습니다.   
동료가 제공한 응답과의 편차로 측정한 외부 데이터 포인트가 올바르지 않다는 전제에 의존하기 때문입니다.   
응답 분포 중 오라클 응답의 위치를 기반으로 유효성 점수를 계산하면 평균보다 정답에 페널티를 줄 위험이 있습니다.   
따라서 ChainLink는 표준 집합 계약을 제공하지만 맞춤형 집합 계약을 지정할 수도 있습니다.  
관련 아이디어는 SchellingCoin 프로토콜입니다. 여기에서 여러 참가자가 값을 보고하고 중앙값을 "정답"으로 간주합니다.   
보고자는 중앙값에 더 가까운 값을 위해 재분배되는 보증금을 제공해야 하므로 다른 값과 유사한 값의 보고를 장려합니다.   
응답자가 조정해야 할 자연스럽고 명백한 대상으로 간주할 수 있는 셸링 포인트라고도 하는 공통 값은 실제 값에 가까울 것으로 예상됩니다.  
TrueBit의 Jason Teutsch는 최근 분산형 오프체인 데이터 가용성 오라클을 위한 새로운 디자인을 제안했습니다.   
이 디자인은 지정된 에포크 동안 등록된 데이터를 사용할 수 있는지 여부를 올바르게 보고할 수 있는 전용 작업 증명 블록체인을 활용합니다.   
광부는 현재 등록된 모든 데이터를 다운로드, 저장 및 전파하려고 시도하므로 데이터를 로컬에서 사용할 수 있습니다.   
이러한 시스템은 모든 마이닝 노드가 등록된 모든 데이터를 저장하고 전파한다는 점에서 비용이 많이 들지만, 시스템은 등록 기간이 끝난 후 데이터를 릴리스하여 스토리지를 재사용할 수 있습니다.  

# Oracle Client Interfaces in Solidity
Oraclize를 사용하여 외부 소스에서 ETH/USD 환율을 업데이트하는 것은 Oraclize를 사용하여 API에서 ETH/USD 가격을 지속적으로 폴링하고 사용 가능한 방식으로 결과를 저장하는 방법을 보여주는 Solidity의 예입니다.  
예 1. Oraclize를 사용하여 외부 소스에서 ETH/USD 환율 업데이트
```
/*
   ETH/USD price ticker leveraging CryptoCompare API

   This contract keeps in storage an updated ETH/USD price,
   which is updated every 10 minutes.
 */

pragma solidity ^0.4.1;
import "github.com/oraclize/ethereum-api/oraclizeAPI.sol";

/*
   "oraclize_" prepended methods indicate inheritance from "usingOraclize"
 */
contract EthUsdPriceTicker is usingOraclize {

    uint public ethUsd;

    event newOraclizeQuery(string description);
    event newCallbackResult(string result);

    function EthUsdPriceTicker() payable {
        // signals TLSN proof generation and storage on IPFS
        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);

        // requests query
        queryTicker();
    }

    function __callback(bytes32 _queryId, string _result, bytes _proof) public {
        if (msg.sender != oraclize_cbAddress()) throw;
        newCallbackResult(_result);

        /*
         * Parse the result string into an unsigned integer for on-chain use.
         * Uses inherited "parseInt" helper from "usingOraclize", allowing for
         * a string result such as "123.45" to be converted to uint 12345.
         */
        ethUsd = parseInt(_result, 2);

        // called from callback since we're polling the price
        queryTicker();
    }

    function queryTicker() external payable {
        if (oraclize_getPrice("URL") > this.balance) {
            newOraclizeQuery("Oraclize query was NOT sent, please add some ETH
                to cover for the query fee");
        } else {
            newOraclizeQuery("Oraclize query was sent, standing by for the
                answer...");

            // query params are (delay in seconds, datasource type,
            // datasource argument)
            // specifies JSONPath, to fetch specific portion of JSON API result
            oraclize_query(60 * 10, "URL",
                "json(https://min-api.cryptocompare.com/data/price?\
                fsym=ETH&tsyms=USD,EUR,GBP).USD");
        }
    }
}
```

Oraclize와 통합하려면 EthUsdPriceTicker 계약이 의 자식이어야 합니다 usingOraclize. usingOraclize 계약은 oraclizeAPI 파일에 정의되어 있습니다.   
데이터 요청은 usingOraclize 계약에서 상속된 oraclize_query 함수를 사용하여 이루어집니다.   
이것은 최소한 두 개의 인수가 필요한 오버로드된 함수입니다.  

•	URL, WolframAlpha, IPFS 또는 계산과 같이 사용할 지원되는 데이터 소스  
•	JSON 또는 XML 구문 분석 도우미의 사용을 포함할 수 있는 주어진 데이터 소스에 대한 인수

가격 쿼리는 queryTicker 함수에서 수행됩니다. 쿼리를 수행하기 위해 Oraclize는 결과를 처리하고 __callback 기능으로 전송하는 가스 비용과 서비스에 대한 추가 요금을 포함하는 작은 수수료를 이더로 지불해야 합니다.   
이 양은 데이터 원본과 필요한 경우 진위 증명 유형(지정된 경우)에 따라 다릅니다.   
데이터가 검색되면 __callback 함수는 콜백을 수행할 권한이 있는 Oraclize 제어 계정에 의해 호출됩니다.   
예를 들어 Oraclize에서 보류 중인 여러 콜백을 처리하고 추적하는 데 사용할 수 있는 고유한 queryId 인수와 응답 값을 전달합니다.  
금융 데이터 제공업체인 Thomson Reuters는 BlockOne IQ라고 하는 이더리움용 오라클 서비스도 제공하여 사설 또는 허가된 네트워크에서 실행되는 스마트 계약에서 시장 및 참조 데이터를 요청할 수 있도록 합니다.   
시장 데이터에 대한 BlockOne IQ 서비스를 호출하는 계약 은 오라클에 대한 인터페이스와 요청을 할 클라이언트 계약을 보여줍니다.  

```
pragma solidity ^0.4.11;

contract Oracle {
    uint256 public divisor;
    function initRequest(
       uint256 queryType, function(uint256) external onSuccess,
       function(uint256
    ) external onFailure) public returns (uint256 id);
    function addArgumentToRequestUint(uint256 id, bytes32 name, uint256 arg) public;
    function addArgumentToRequestString(uint256 id, bytes32 name, bytes32 arg)
        public;
    function executeRequest(uint256 id) public;
    function getResponseUint(uint256 id, bytes32 name) public constant
        returns(uint256);
    function getResponseString(uint256 id, bytes32 name) public constant
        returns(bytes32);
    function getResponseError(uint256 id) public constant returns(bytes32);
    function deleteResponse(uint256 id) public constant;
}

contract OracleB1IQClient {

    Oracle private oracle;
    event LogError(bytes32 description);

    function OracleB1IQClient(address addr) external payable {
        oracle = Oracle(addr);
        getIntraday("IBM", now);
    }

    function getIntraday(bytes32 ric, uint256 timestamp) public {
        uint256 id = oracle.initRequest(0, this.handleSuccess, this.handleFailure);
        oracle.addArgumentToRequestString(id, "symbol", ric);
        oracle.addArgumentToRequestUint(id, "timestamp", timestamp);
        oracle.executeRequest(id);
    }

    function handleSuccess(uint256 id) public {
        assert(msg.sender == address(oracle));
        bytes32 ric = oracle.getResponseString(id, "symbol");
        uint256 open = oracle.getResponseUint(id, "open");
        uint256 high = oracle.getResponseUint(id, "high");
        uint256 low = oracle.getResponseUint(id, "low");
        uint256 close = oracle.getResponseUint(id, "close");
        uint256 bid = oracle.getResponseUint(id, "bid");
        uint256 ask = oracle.getResponseUint(id, "ask");
        uint256 timestamp = oracle.getResponseUint(id, "timestamp");
        oracle.deleteResponse(id);
        // Do something with the price data
    }

    function handleFailure(uint256 id) public {
        assert(msg.sender == address(oracle));
        bytes32 error = oracle.getResponseError(id);
        oracle.deleteResponse(id);
        emit LogError(error);
    }

}
```

데이터 요청은 두 개의 콜백 함수 외에 쿼리 유형(이 예에서는 일중 가격에 대한 요청)을 지정할 수 있는 initRequest 함수를 사용하여 시작됩니다.   
그러면 추가 인수를 제공하는 데 사용할 수 있는 uint256 식별자가 반환됩니다.  
addArgumentToRequestString 함수는 여기에서 IBM 주식에 대한 Reuters Instrument Code(RIC)를 지정하는 데 사용되며 addArgumentToRequestUint타임스탬프를 지정할 수 있습니다.   
이제 block.timestamp에 대한 별칭을 전달하면 IBM의 현재 가격이 검색됩니다.   
그런 다음 요청은 executeRequest 함수에 의해 실행됩니다.   
요청이 처리되면 Oracle 계약은 쿼리 식별자로 onSuccess 콜백 함수를 호출하여 결과 데이터를 검색할 수 있도록 합니다.   
검색 실패의 경우,onFailure콜백은 대신 오류 코드를 반환합니다. 성공 시 검색할 수 있는 사용 가능한 필드에는 시가, 고가, 저가, 종가(OHLC) 및 입찰/매도가가 있습니다  

# Conclusions
오라클은 스마트컨트랙트에 중요한 서비스를 제공함  
오라클은 컨트랙트 수행에 외부의 사실 정보를 제공함  
또한 오라클이 오염된다면 스마트컨트랙트에게 치명적인 리스크도 가져올 수 있음  

오라클 사용을 고려한다면 신뢰 모델에 대해서 깊게 주의해야함  
오라클을 너무 믿으면, 잠재적인 오류 입력에 대해서 스마트컨트랙트을 노출하게되므로 보안에 주의해야함  

분산 오라클이 위에 언급된 우려를 일부 해소할 수 있음   
이더리움과 오라클이 제공하는 현실 세계 사이에서 브릿지를 주의깊게 연결해야 함  
