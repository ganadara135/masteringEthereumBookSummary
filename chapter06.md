# Transactions
트랜잭션은 EOA 로 디지털 서명된 메시지이고,  
이더리움 네트워크로 전송되고,  
이더리움 블록체인에 기록됨.  
트랜잭션은 상태의 변화를 일으키고, EVM 에서 컨트랙트를 실행함  

이더리움은 글로벌 싱글톤 상태 머신이다  
트랜잭션이 상태 머신의 변화를 만듦  
컨트랙트 같이 모든 것이 트랜잭션에서 실행됨  
본 챕터에서 트랜잭션을 분석해봄  
어떻게 작동하고, 그 디테일을 볼 것임  
트랜잭션을 로우 레벨에서 분석해 보길 원하는 개발자라면 흥미 있을 것임  

# The Structure of a Transaction
트랜잭션은 이더리움 네트워크에서 직렬화되어서 전송됨  
직렬화된 트랜잭션을 받은 클라이언트 어플은 자체 데이터 구조체를 사용해서 내부 메모리에 저장할 것임  
자체 데이터 구조체는 직렬화된 트랜잭션 자체가 네트워크엔 존재하지 않은 메타데이터로 꾸며져 있음  
직렬화된 네트워크가 트랜잭션의 유일한 표준 형태임

트랜잭션은 아래와 같은 데이터를 직렬화된 이진 메시지임
+ Nonce  
  EOA 가 발행하는 시퀀스 숫자, 메시지 재전송을 막기 위해 사용됨  
+ Gas price  
  이더의 양, 트랜잭션 전송을 위한 수수료
+ Gas limit  
  트랜잭션을 전송하기 위해서 지불할 수 있는 최대 값  
+ Recipient    
  수령자 이더리움 주소  
+ Value  
  도착지에 보낼 이더의 양  
+ Data  
  변수의 길이, 이진 데이터 페이로드
+ v,r,s  
  EOA 용 ECDSA 디지털 서명을 위한 세 가지 요소    

트랜잭션 메시지 구조는 RLP 인코드 체계를 사용하여서 직렬화 됨  
이더리움에서 모든 숫자는 big-endian 정수로 인코드 됨  
길이는 다수의 8비트 임.  
수령자, 이더 양과 같은 필드 라벨은 여기서 명확성을 위해서 사용하나 
RLP 인코드된 필드값을 포함하는 직렬화된 트랜잭션 데이터는 아님  
일반적으로 RLP는 필드 구분자나 라벨을 포함하지 않음  
RLP 길이 저사는 각 필드의 길이를 구분하기 위해 사용함  
정의된 길이를 넘어서는 어떤 값도 다음 필드에 속하게 됨  

이것이 전송되는 실제 트랜잭션이고,  
대부분의 내부 표현과 사용자 인터페이스 표기는 트랜잭션에서 유도하는 추가적인 정보를 사용해서 이것을 꾸밈  

예로서, EOA를 구분하는 주소 안에 from 데이터가 비여 있음  
왜냐하면 EOA의 공개키는 ECDSA 시그니처의 v,r,s 요소로 부터 유추할 수 있음  
주소는 공개키를 통해서 추출할 수 있음  
from 필드를 나타내는 트랜잭션이 있다면,  
트랜잭션을 표현하기 위해서 사용되는 소프트웨어에 의해서 넣어 짐  
클라이언트 소프트웨어에 의해서 트랜잭션에 넣어진 다른 메타데이터들은 블록 넘버와 트랜잭션 아이디가 있음  
이런 데이터들은 트랜잭션에서 유도되지,  트랜잭션 메시지 자체가 아님  


# The Transaction Nonce
Nonce 의 정의, in Yellow Paper
___
+nonce+: 스칼라 값은 해당 주소에서 보내진 트랜잭션 숫자와 같다. 또는 해당 계정에서 만들어진 컨트랙트 생성 숫자.
___

간단히 말해서 nonce 는 기원 주소의 속성임  
즉, 보내는 주소의 컨텍스트에서 의미를 가짐  
nonce 는 블록체인의 계정 상태의 일부로서 명확히 저장되지 않음  
주소에서 기원한 확정된 트랜잭션 수를 계산해서 유동적으로 계산함  

트랜잭션 nonce 카운팅 존재가 중요한 2가지 시나리오가 있음  
생성 순서에 포함되는 트랜잭션의 사용 특성과 트랜잭션 복제 방지하는 활성 특성임  
각각의 시나리오 예는 아래와 같음  
1. 2개의 트랜잭션을 만들기 원한다고 가정하자.  
   6 이더를 사용하는 지불 절차가 있음  
   또한 8 이더의 지불 절차가 있음  
   6 이더 트랜잭션을 먼저 사인하고 발송함  
   그리고 두 번째 8 이더 트랜잭션을 사인하고 발송함  
   슬프게 당신 계좌는 오직 10 이더만 있다는 것 알아차리지 못했음  
   따라서 네트워크는 위 2개의 트랜잭션을 처리하지 못함  
   당신은 더 중요하다고 여긴 6 이더를 먼저 보냈기 때문에,  
   당신은 6 이더 전송은 성공하고 8 이더는 거부될 것이라고 기대함  
   하지만, 이더리움 같은 분산 시스템에서 노드들은 위 2개의 순서로 트랜잭션을 받음.  
   다른 것에 앞서 특정 노드가 하나의 트랜잭션을 가질 것이라는 보장은 없음  
   일부 노드는 6 이더 트랜잭션을 먼저 받을 것이고,  
   다른 노드는 8 이더 트랜잭션을 먼저 받을 것이다  
   nonce 가 없다면, 일부는 처리되고, 일부는 거부되는게 랜덤으로 발생할 것임  
   하디만 nonce 가 있다면 6 이더를 전송하는 첫번째 트랜잭션과  
   8 이더를 전송하는 두번째 트랜잭션의 nonce 값에 의해서 순서적으로 처리될 것임  
   
2. 당신이 100 이더를 가진 계정이 있다고 상상하자  
   온라인에서 누군가 맥프로 노트북을 이더로 판매한다  
   당신은 2 이더를 보내고, 판매자가 노트북을 보낸다  
   2 이더 지불을 위해서 당신의 계정에서 판매자 계정으로 2 이더를 보내는  
   트랜잭션에 사인함  
   그 이후에 해당 트랜잭션을 이더리움 네트워크와 전송하여서  
   블록체인에 검증되고 포함되게 함  
   트랜잭션에 nonce 값이 없이 같은 주소로 2번 연속으로 2 이더를 보내는 경우  
   첫번째 트랜잭션와 정확히 같은 트랜잭션이 만들어 질 것임  
   이것은 누구든지 이더리움 네트워크에서 당신의 트랜잭션을 본다면  
   해당 트랜잭션을 여러번 재전송할 수 있음을 의미함  
   다신의 전체 이더가 제로가 될때까지 재전송할 수 있음  
   하지만 트랜잭션 데이터에 nonce 값이 포함되어 있다면  
   모든 트랜잭션은 유니크함을 보장함  
   그리하여서 트랜잭션의 데이터 중에 증가하는 값인 nonce 값이 있으면  
   지불이 이중으로 발생하는 것이 불가함  
   
결론으로 계정 중심 프로토콜에서 nonce 의 사용은 정말 중요하다  
비트코인의 UTXO 메커니즘과는 대비된다  

## Keeping Track of Nonces
nonce 는 하나의 계정으로 기원하는 최종 검증된 트랜잭션의 최신 카운트 숫자이다  
Web3 인터페이스를 통해서 nonce를 확인할 수 있다  
Ropsten testnet 위에서 작동하는 Geth 에서 자바스크립트 콘솔을 열고 아래와 같이 타입팅하라.  
```
>web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f")
40
```
|  |  |
|--|--|
|Tip|Nonce 는 0 에서 시작하는 카운터임. 따라서 첫번째 트랜잭션은 nonce 0 임  현재 트랜잭션 nonce 가 40 이라면, nonce 0 에서 39 까지 있음을 의미함|

지갑 소프트웨어가 각 주소의 nonce를 추적함  
구체적으로는 아래와 같다  
새 트랜잭션을 생성하면 연속적인 다음 nonce를 할당함  
하지만, 해당 nonce 는 최종 확인이 끝난게 아님  
|  |  |
|--|--|
|Warning|대기하고 있는 트랜잭션을 카운팅하는 getTransactionCount 함수를 사용할 때 주의 필요, 특히 연속적으로 트랜잭션을 보낼때 주의하라| 

위와 같은 우려 사항을 예제를 확인해 보자  
```
> web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f", \
"pending")
40
> web3.eth.sendTransaction({from: web3.eth.accounts[0], to: \
"0xB0920c523d582040f2BCB1bD7FB1c7C1ECEbdB34", value: web3.utils.toWei(0.01, "ether")});
> web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f", \
"pending")
41
> web3.eth.sendTransaction({from: web3.eth.accounts[0], to: \
"0xB0920c523d582040f2BCB1bD7FB1c7C1ECEbdB34", value: web3.utils.toWei(0.01, "ether")});
> web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f", \
"pending")
41
> web3.eth.sendTransaction({from: web3.eth.accounts[0], to: \
"0xB0920c523d582040f2BCB1bD7FB1c7C1ECEbdB34", value: web3.utils.toWei(0.01, "ether")});
> web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f", \
"pending")
41
```
우와같이 첫 트랜잭션이 카운트가 41 이고, 대기중(pending) 임을 보여준다  
3개의 트랜잭션을 연속적으로 빠르게 보내면, getTransactionCount 는  해당 트랜잭션들을 카운트하조 못한다.  
따라서 대기중 트랜잭션이 있을 경우에는 주의가 필요함  

트랜잭션을 직접 작성하는 어플을 만든다면,  단순히 getTransactionCount 에만 의지하지 말라  
대기중(pending) 이고 확인된 카운트가 같을때의 getTransactionCount 의 결과를 nonce 카운트로 사용할 수 있음  
따라서 모든 트랜잭션이 확인될때까지 어플에서는 nonce 를 추적해야 함  

Parity's JSON RPC 인터페이스는 parity_nextNonce 함수를 제공  
위 함수는 연속적인 트랜잭션 전송과 상관없이 정확한 nonce 결과를 전달함  
```
$ curl --data '{"method":"parity_nextNonce", \
  "params":["0x9e713963a92c02317a681b9bb3065a8249de124f"],\
  "id":1,"jsonrpc":"2.0"}' -H "Content-Type: application/json" -X POST \
  localhost:8545

{"jsonrpc":"2.0","result":"0x32","id":1}
```

## Gaps in Nonces, Duplicate Nonces, and Confirmation
직접적으로 트랜잭션 생성해야 한다면 nonce 추적이 중요함  
특히 복수의 독립적인 프로세스를 동시적으로 처리해야 하다면 특히 중요함  

이더리움 네트워크는 nonce 를 기초로하여서 연속적으로 트랜잭션을 처리함  
만약 nonce 0 번으로 트랜잭션을 전송하고, 바로 nonce 2번으로 트랜잭션을 또 전송하면  
두번째 트랜잭션을 블록에 포함되지 않음  
해당 트랜잭션은 mempool 에 저장될 것이다.  
그리고 이더리움 네트워크에선 분실된 nonce 가 나타날 때까지 기다릴 것임 
모든 노드들은 분실된 nonce 가 단순히 딜레이 되거나 시퀀스가 안 맞았다고 여길 것임  

만약 그 시점에 분실된 nonce 1 번의 트랜잭션을 보내면, nonce 1과 2번의 트랜잭션이 처리될 것임  
일단 그 갭이 채워지면, 네트워크는 mempool 에 가지고 있던 시퀀스가 안 맞는 트랜잭션을 채굴할 수 있음  

하지만 트랜잭션을 재호출(recall)은 가능하지 않음  
한편 nonce 가 복제되여 겹치게 됩다면, 아주 랜덤하게 하나는 처리되고, 하나는 거부될 것임  

반면, 동일한 비수신자 또는 값이 다른 두 트랜잭션을 전송하여 실수로 비수신자를 복제하는 경우 중 하나가 확인되고 거부됩니다.   
어떤 것이 확인되는지는 수신하는 첫 번째 유효화 노드에 도착하는 순서에 따라 결정됩니다.   
즉, 상당히 무작위적입니다.

보시다시피, 한 번 이상 추적해야 하며, 응용프로그램이 해당 프로세스를 올바르게 관리하지 못할 경우 문제가 발생합니다.   
유감스럽게도, 이 작업을 동시에 수행하려고 하면 다음 섹션에서 볼 수 있듯이 상황이 더욱 어려워집니다.  

## Concurrency, Transaction Origination, and Nonces
동시성은 컴퓨터 과학의 복잡한 측면이며, 특히 Ethereum과 같이 분산되고 분산되어 있는 실시간 시스템에서 예상치 못하게 발생하기도 합니다.

간단히 말해서 동시성은 여러 독립적인 시스템에 의해 동시에 계산되는 경우를 의미합니다.   
동일한 프로그램(예: 멀티스레딩), 동일한 CPU(예: 다중 처리) 또는 서로 다른 컴퓨터(예: 분산 시스템)에 있을 수 있습니다.   
Ethereum은 정의상 운영(노드, 클라이언트, DApps)의 동시성은 허용하지만 합의를 통해 단일 상태를 강제하는 시스템입니다.  

이제 동일한 주소 또는 주소에서 트랜잭션을 생성하는 독립 지갑 응용 프로그램이 여러 개 있다고 가정해 보십시오.   
이러한 상황의 한 예는 거래소의 핫월렛(키가 온라인에 저장되어 있는 지갑, 키가 온라인에 있지 않은 콜드월렛과 대조되는 지갑)에서 교환을 처리하는 것입니다.   
이상적으로는 병목 현상이나 단일 장애 지점이 되지 않도록 둘 이상의 컴퓨터 처리 인출이 필요합니다.   
그러나 둘 이상의 컴퓨터가 출금을 생성하게 되면 일부 곤란한 동시성 문제가 발생하게 되고 그 중 가장 중요한 것은 부정기 선정이기 때문이다.   
동일한 핫월렛 계정에서 트랜잭션을 생성, 서명 및 브로드캐스트하는 여러 컴퓨터를 어떻게 조정합니까?  

단일 시스템을 사용하여 선착순으로 트랜잭션 서명 시스템에 nonce를 할당할 수 있습니다.   
그러나 이 컴퓨터는 이제 단일 장애 지점이 되었습니다. 더 나쁜 것은 여러 번 nonce를 할당했는데 그 중 하나가 사용되지 않으면(한 번 할당되지 않은 트랜잭션을 처리하는 컴퓨터에서 오류가 발생하여) 이후의 모든 트랜잭션이 중단된다는 것입니다.  

또 다른 접근방식은 거래를 생성하되, 비거래를 할당하지 않는 것이다(따라서 서명되지 않은 상태로 두는 것).   
비거래는 거래 데이터의 필수적인 부분이기 때문에 거래를 인증하는 디지털 서명에 포함될 필요가 있다는 것을 기억한다.   
그런 다음 서명하고 비회수를 추적하는 단일 노드에 대기열을 둘 수 있습니다.   
다시 말하지만, 이것은 공정의 초크 포인트가 될 것입니다.   
한 번 서명하고 추적하는 것은 부하로 인해 혼잡해질 가능성이 높은 운영의 일부인 반면 서명되지 않은 트랜잭션의 생성은 실제로 병렬화할 필요가 없는 부분입니다.   
어느 정도 동시성이 있을 수 있지만, 프로세스의 중요한 부분이 부족할 수 있습니다.  
결국, 이러한 동시성 문제는 독립적인 프로세스에서 계좌 잔액과 거래 확인을 추적하는 어려움에 더해, 대부분의 구현이 동시성을 피하고 단일 프로세스가 교환에서 모든 인출 트랜잭션을 처리하거나 여러 핫 월렛을 설정하는 등의 병목 현상을 발생시킵니다.  
n은 인출에 대해 완전히 독립적으로 작동하며 간헐적으로 균형을 재조정하기만 하면 됩니다.  

# Transaction Gas
가스에 대해서는 앞 장에서 조금 다루었고, 자세한 내용은 [가스]에서 다루었습니다. 그러나 거래에서 가스 가격 및 가스 제한 구성요소의 역할에 대한 몇 가지 기본 사항을 살펴보겠습니다.  

가스는 Ethereum의 연료입니다.   
가스는 이더가 아닙니다.  
이더에 대한 자체 환율이 있는 별도의 가상화폐입니다.   
이더리움은 전 세계 수천 대의 컴퓨터에서 처리되기 때문에 거래에 사용할 수 있는 자원의 양을 제어하기 위해 가스를 사용한다.   
개방형(Turing-complete) 계산 모델은 서비스 거부 공격 또는 실수로 리소스를 낭비하는 트랜잭션을 방지하기 위해 일종의 미터링을 필요로 합니다.  

가스는 이더 가치의 급격한 변화와 함께 발생할 수 있는 변동성으로부터 시스템을 보호하고 가스가 지불하는 다양한 자원(즉, 계산, 메모리 및 스토리지)의 비용 간에 중요하고 민감한 비율을 관리하기 위해 이더와 분리되어 있습니다.  

거래의 가스 가격 필드는 거래 개시자가 가스 대신 지불할 의향이 있는 가격을 설정할 수 있도록 해줍니다.   
가격은 가스 단위당 웨이 단위로 측정됩니다.   
예를 들어 [intro_chapter]의 표본 거래에서 지갑은 가스 가격을 3gwei(3기가웨이 또는 30억웨이)로 설정합니다.  
|  |  |  
|--|--|  
|팁|인기 사이트 ETH 주유소는 Ethereum 메인 네트워크에 대한 가스 및 기타 관련 가스 측정 기준에 대한 정보를 제공합니다.|  

지갑은 거래 확인 속도를 높이기 위해 발생한 거래에서 가스 가격을 조정할 수 있습니다.   
가스 가격이 높을수록 거래 확정이 빨라질 것으로 보인다.   
반대로 우선 순위가 낮은 거래는 가격을 낮추어 확인이 더 느려질 수 있습니다.   gasPrice가 설정할 수 있는 최소값은 0으로, 무수수 거래를 의미합니다.   
블록의 공간 수요가 적은 기간에는 이러한 트랜잭션을 마이닝할 수 있습니다.  
|  |  |  
|--|--|  
|노트|허용되는 최소 가스 가격은 0입니다. 이는 지갑이 완전히 자유로운 거래를 창출할 수 있다는 것을 의미한다. 용량에 따라 이러한 사항은 절대 확인되지 않을 수 있지만 프로토콜에는 무료 거래를 금지하는 내용이 없습니다. Ethereum 블록체인에 이러한 트랜잭션의 몇 가지 예가 포함되어 있습니다.|  

web3 인터페이스는 여러 블록에 걸쳐 중간 가격을 계산하여 gasPrice 제안을 제공합니다(트러플 콘솔 또는 JavaScript web3 콘솔을 사용하여 이를 수행할 수 있습니다).  
```
> web3.eth.getGasPrice(console.log)
> null BigNumber { s: 1, e: 10, c: [ 10000000000 ] }
```
가스와 관련된 두 번째 중요한 분야는 가스 한계입니다.   
간단히 말해, gasLimit는 거래 개시자가 거래를 완료하기 위해 구매하고자 하는 최대 가스 단위 수를 제공합니다.  
한 EOA에서 다른 EOA로 에테르를 이전하는 간편결제의 경우 필요한 가스량은 2만1000가스로 고정된다.   
이더 가격이 얼마인지 계산하려면 2만 1천에 가스 가격을 곱하면 됩니다. 예:  
```
> web3.eth.getGasPrice(function(err, res) {console.log(res*21000)} )
> 210000000000000
```
거래 목적지 주소가 계약인 경우 필요한 가스량을 추정할 수 있지만 정확하게 결정할 수는 없습니다.   
그 이유는 계약에 따라 총 가스 비용이 서로 다른 실행 경로로 이어지는 여러 조건을 평가할 수 있기 때문입니다.   
계약은 사용자의 통제를 벗어나 예측할 수 없는 조건에 따라 단순 계산만 실행하거나 더 복잡한 계산만 실행할 수 있습니다.   
이를 입증하기 위해 예를 들어, 호출될 때마다 카운터를 증가시키고 호출 횟수와 동일한 특정 루프를 실행하는 스마트컨트랙트을 작성할 수 있습니다.   
아마 100번째 통화에서는 추첨처럼 특별한 경품을 주지만, 경품을 계산하기 위해서는 추가적인 계산이 필요합니다.   
계약서에 99번 전화하면 한 가지 일이 생기는데, 100번 전화하면 아주 다른 일이 일어납니다.   
당신이 지불하는 기름의 양은 당신의 거래가 블록에 포함되기 전에 얼마나 많은 다른 거래들이 그 기능을 호출했느냐에 달려있습니다.   
아마도 당신의 견적은 99번째 거래일 수도 있지만, 당신의 거래가 확정되기 직전에 다른 사람이 99번째 계약서에 전화를 합니다.   
이제 귀하는 100번째 상담자이며, 계산 작업(및 가스 비용)이 훨씬 더 높습니다.  

Ethereum에서 사용되는 일반적인 유사점을 빌리자면, GasLimit를 자동차 연료 탱크의 용량으로 생각하면 됩니다(차량은 거래량임).   
여정에 필요한 만큼의 가스를 탱크에 채웁니다(거래를 검증하는 데 필요한 계산).  
어느 정도 금액을 추정할 수 있지만, 연료 소비량을 증가시키는 전환(더 복잡한 실행 경로)과 같은 예상치 못한 전환이 있을 수 있습니다.  

그러나 연료탱크에 대한 비유는 다소 오해를 불러일으킨다.   
사실 주유소 회사의 신용 계좌에 가깝습니다.   
여행 완료 후 결제하는 곳은 실제로 얼마나 많은 기름을 사용했는지에 따라 다릅니다.  
거래를 전송할 때 첫 번째 확인 단계 중 하나는 해당 거래가 시작된 계정에 가스 가격 * 가스 한도를 지불하기에 충분한 이더가 있는지 확인하는 것입니다.   
그러나 이 금액은 거래가 완료될 때까지 당신의 계좌에서 실제로 공제되지 않습니다.  
거래에서 실제로 소비되는 기름값만 청구되지만, 거래 전에 지불할 최대 금액만큼 잔액이 충분히 있어야 합니다.  

# Transaction Recipient
트랜잭션의 수신인은 대상 필드에 지정됩니다.   
여기에는 20바이트 Ethereum 주소가 포함되어 있습니다.   
주소는 EOA 또는 계약 주소일 수 있습니다.

Ethereum은 이 필드에 대한 추가 유효성 검사를 수행하지 않습니다.   
모든 20바이트 값은 유효한 것으로 간주됩니다.   
20바이트 값이 해당 개인 키가 없거나 해당 계약이 없는 주소에 해당하더라도 트랜잭션은 여전히 유효합니다.   
Ethereum은 주소가 공용 키(따라서 개인 키)에서 올바르게 파생되었는지 여부를 알 수 있는 방법이 없습니다.  
|  |  |
|--|--|  
|경고|Ethereum 프로토콜은 트랜잭션에서 수신자 주소의 유효성을 검사하지 않습니다. 해당하는 개인 키나 계약이 없는 주소로 보내 에테르를 "구워서" 영원히 사용할 수 없게 만들 수 있습니다. 검증은 사용자 인터페이스 수준에서 수행해야 합니다.|  

트랜잭션을 잘못된 주소로 보내면 보낸 이더가 연소되어 대부분의 주소에 알려진 개인 키가 없기 때문에 이더에 영원히 액세스할 수 없게 됩니다(사용 불가).   
주소의 유효성 검사는 사용자 인터페이스 수준에서 이루어지는 것으로 가정합니다([EIP55] 참조).   
실제로, 이더를 태우는 데는 여러 가지 타당한 이유가 있습니다.   
예를 들어, 결제 채널 및 기타 스마트 계약의 부정 행위에 대한 동기부여로, 그리고 에테르 양이 한정되어 있기 때문에, 이더를 태우는 것은 모든 이더 보유자에게 연소된 가치를 효과적으로 분배합니다(보유하는 이더 양에 비례합니다).  


# Transaction Value and Data
트랜잭션의 주요 "페이로드"는 가치와 데이터의 두 가지 필드에 포함됩니다. 트랜잭션에는 가치와 데이터, 값만 있을 수 있고, 데이터만 있을 수 있으며, 값도 데이터도 있을 수 없습니다. 네 가지 조합이 모두 유효합니다.

가치만 있는 거래는 지급입니다. 데이터만 있는 트랜잭션은 호출입니다. 가치와 데이터가 모두 포함된 트랜잭션은 지급과 호출입니다. 가치도 데이터도 없는 거래는 아마도 가스 낭비일 것입니다! 하지만 그것은 여전히 가능합니다.

이 모든 조합을 시도해 봅시다. 먼저 데모를 보다 쉽게 읽을 수 있도록 지갑에서 소스 및 대상 주소를 설정합니다.  
```
src = web3.eth.accounts[0];
dst = web3.eth.accounts[1];
```
첫 트랜잭션은 오직 값(지불)과 페이로드 데이터 없는 값을 포함함  
```
web3.eth.sendTransaction({from: src, to: dst, \
  value: web3.utils.toWei(0.01, "ether"), data: ""});  
```
우리의 지갑은 패리티 지갑에 표시된 것과 같이 보낼 값을 나타내는 확인 화면을 보여주지만 데이터는 없습니다.  
![figure 1](https://github.com/ethereumbook/ethereumbook/raw/develop/images/parity_txdemo_value_nodata.png)  

다음 예제에서는 값과 데이터 페이로드를 모두 지정합니다.  
```
web3.eth.sendTransaction({from: src, to: dst, \
  value: web3.utils.toWei(0.01, "ether"), data: "0x1234"});
```
우리의 지갑은 패리티 지갑에서 볼 수 있듯이 보낼 값과 데이터 페이로드를 나타내는 확인 화면을 보여주며, 가치와 데이터가 있는 트랜잭션을 보여줍니다.  
![figure 2](https://github.com/ethereumbook/ethereumbook/raw/develop/images/parity_txdemo_value_data.png)  
그림 2. 가치와 데이터가 있는 트랜잭션을 보여주는 패리티 지갑
다음 트랜잭션에는 데이터 페이로드가 포함되지만 값이 0으로 지정됩니다.  
```
web3.eth.sendTransaction({from: src, to: dst, value: 0, data: "0x1234"});
```
패리티 지갑에 표시된 것과 같이, 우리의 지갑은 제로 값과 데이터 페이로드를 나타내는 확인 화면을 보여주며, 아무런 가치도 없는 거래는 데이터만 보여줍니다.  
![figure 3](https://github.com/ethereumbook/ethereumbook/raw/develop/images/parity_txdemo_novalue_data.png)  
그림 3. 값 없이 데이터만 있는 트랜잭션을 표시하는 패리티 지갑
마지막으로, 마지막 트랜잭션에는 전송할 값도 데이터 페이로드도 포함되지 않습니다.  
```
web3.eth.sendTransaction({from: src, to: dst, value: 0, data: ""}));
```
저희 지갑은 패리티 지갑에 표시된 것과 같이 0 값을 나타내는 확인 화면을 보여주며, 아무런 가치도 없는 거래와 데이터도 없습니다.  
![gigure 4](https://github.com/ethereumbook/ethereumbook/raw/develop/images/parity_txdemo_novalue_nodata.png)  
그림 4. 값도 데이터도 없는 트랜잭션을 표시하는 패리티 지갑  

## Transmitting Value to EOAs and Contracts
값이 포함된 Ethereum 트랜잭션을 구성할 때 해당 트랜잭션은 지급에 해당합니다.   
이러한 트랜잭션은 대상 주소가 계약인지 여부에 따라 다르게 동작합니다.

EOA 주소 또는 블록체인에 계약으로 플래그가 지정되지 않은 주소에 대해 Ethereum은 상태 변경을 기록하고 주소 잔액에 보낸 값을 추가합니다.   
주소가 이전에 표시되지 않은 경우, 해당 주소는 고객의 상태 내부 표현에 추가되고 결제 금액으로 초기화됩니다.

대상 주소가 계약인 경우, EVM은 계약을 실행하고 트랜잭션의 데이터 페이로드에 명명된 함수를 호출합니다.   
거래에 데이터가 없는 경우, EVM은 폴백 함수를 호출하고, 해당 기능이 유료인 경우 이를 실행하여 다음에 수행할 작업을 결정합니다.   
폴백 기능에 코드가 없으면 거래의 효과는 지갑 결제와 똑같이 계약 잔액을 늘리는 것입니다.   
폴백 기능 또는 미납 폴백 기능이 없는 경우 트랜잭션이 반환됩니다.  

계약은 함수를 호출할 때 즉시 예외를 두거나 함수에 코드화된 조건에 따라 결정함으로써 들어오는 지급을 거부할 수 있습니다.   
기능이 성공적으로 종료되는 경우(예외 없이), 계약의 상태는 계약의 이더 잔액의 증가를 반영하도록 갱신된다.  

## Transmitting a Data Payload to an EOA or Contract
트랜잭션에 데이터가 포함된 경우 대부분 계약 주소로 주소가 지정됩니다.   
그렇다고 데이터 페이로드를 EOA에 전송할 수 없는 것은 아닙니다.   
Ethereum 프로토콜에서 완전히 유효합니다.   
그러나 이 경우 데이터의 해석은 EOA에 액세스하는 데 사용하는 지갑에 달려 있습니다.   
Ethereum 프로토콜에서 무시됩니다.   
또한 대부분의 지갑은 자신이 제어하는 EOA에 대한 트랜잭션에서 수신된 모든 데이터를 무시합니다.   
앞으로 지갑이 계약처럼 데이터를 해석해 사용자 지갑 안에서 실행되는 기능을 발동할 수 있는 표준이 등장할 가능성이 있다.   
중요한 차이점은 EOA에 의한 데이터 페이로드 해석은 계약 실행과 달리 Ethereum의 합의 규칙을 따르지 않는다는 점이다.  

지금은 거래가 계약 주소로 데이터를 전송한다고 가정해 보겠습니다.   
이 경우, 데이터는 EVM에 의해 계약 호출로 해석됩니다.   
대부분의 계약에서는 이 데이터를 함수 호출로 보다 구체적으로 사용하여 명명된 함수를 호출하고 인코딩된 인수를 함수에 전달합니다.

ABI 호환 계약(모든 계약이 그렇다고 가정할 수 있음)으로 전송되는 데이터 페이로드는 다음의 16진수 인코딩입니다.  

#### 함수 선택자  
함수 프로토타입의 Keccak-256 해시의 처음 4바이트입니다. 이를 통해 계약은 어떤 기능을 호출할지 명확하게 식별할 수 있습니다.  

#### 함수 인자  
ABI 규격에 정의된 다양한 기본 유형에 대한 규칙에 따라 인코딩된 함수의 인수입니다.  

[solidity_faucet_example]에서는 인출 함수를 정의했습니다.  
```
function withdraw(uint withdraw_amount) public {
```
함수의 프로토타입은 함수의 이름이 포함된 문자열과 각 인수(괄호 안에 묶고 쉼표로 구분)의 데이터 형식으로 정의됩니다.   
여기서 함수 이름은 unt이고 unt256의 별칭인 단일 인수가 필요하므로 unt256의 프로토타입은 다음과 같습니다.  
```
withdraw(uint256)
```
이 문자열의 Keccak-256 해시를 계산해 보겠습니다.  
```
> web3.utils.sha3("withdraw(uint256)");
'0x2e1a7d4d13322e7b96f9a57413e1525c250fb7a9021cf91d1540d5b69f16a49f'
```
해시의 처음 4바이트는 0x2e1a7d4d입니다. 이것이 우리의 "기능 선택기" 값이며, 어떤 기능을 호출하고 싶은지 계약에 알려줄 것입니다.

다음으로, 인수가 detrace_mount로 전달할 값을 계산하겠습니다. 0.01 이더를 인출하고 싶습니다.   
이를 wei로 표시된 16진수 빅 엔디안 부호 없는 256비트 정수로 인코딩해 보겠습니다.  
```
> withdraw_amount = web3.utils.toWei(0.01, "ether");
'10000000000000000'
> withdraw_amount_hex = web3.utils.toHex(withdraw_amount);
'0x2386f26fc10000'
```
이제 함수 선택기를 32바이트에 추가했습니다.  
```
2e1a7d4d000000000000000000000000000000000000000000000000002386f26fc10000
```
그것은 우리의 거래에 대한 데이터 페이로드이며, 인출 함수를 호출하고 0.01 이더를 인출_금액으로 요청합니다.   


# Special Transaction: Contract Creation
우리가 언급해야 할 한 가지 특별한 경우는 블록체인에 새로운 계약을 만들어 향후 사용을 위해 배치하는 거래입니다.   
계약 작성 트랜잭션은 0 주소라는 특수 대상 주소로 전송됩니다.   
계약 등록 트랜잭션의 대상 필드에는 0x0 주소가 포함됩니다.   
이 주소는 EOA(해당 민간-공용 키 쌍이 없음)와 계약을 나타내지 않는다.   
이더를 쓰거나 거래를 시작할 수 없습니다.   
"이 계약을 맺다"라는 특별한 의미를 가진 목적지로만 사용됩니다.

영(0)주소는 계약창출만을 목적으로 하지만 때로는 다양한 주소에서 대금을 지급받기도 한다.   
여기에는 두 가지 설명이 있습니다.   
즉, 우연히 이더가 손실되거나 의도적인 이더 화상(절대 사용할 수 없는 주소로 이더를보내 의도적으로 파괴하는 것)입니다.   
그러나 의도적인 이더 굽기를 수행하려면 네트워크에 의도를 명확히 하고 특별히 지정된 굽기 주소를 대신 사용해야 합니다.  
```
0x000000000000000000000000000000000000dEaD
```
|  |  |
|--|--|  
|경고|지정된 굽기 주소로 보낸 이더를 사용할 수 없게 되어 영구적으로 손실됩니다.|  

계약 작성 트랜잭션에는 계약을 작성할 컴파일된 바이트 코드를 포함하는 데이터 페이로드만 있으면 됩니다.   
이 거래의 유일한 효과는 계약을 만드는 것이다.   
시작 잔액을 사용하여 새 계약을 설정하려는 경우 값 필드에 이더 금액을 포함할 수 있지만 이 금액은 전적으로 선택 사항입니다.   
데이터 페이로드(계약 없음) 없이 값(이더)을 계약 작성 주소로 보내는 경우 효과는 화상 주소로 보내는 것과 동일합니다.   
크레딧할 계약이 없으므로 이더가 손실됩니다.

예를 들어 수도꼭지를 만들 수 있습니다.  
[sol_chapter]에서 데이터 페이로드에 있는 계약과 함께 0 주소에 대한 트랜잭션을 수동으로 생성하여 사용되는 sol contract.    
계약은 바이트코드 표현으로 컴파일되어야 합니다.   
Solidity 컴파일러를 사용하면 다음과 같은 작업을 수행할 수 있습니다.  
```
$ solc --bin Faucet.sol

Binary:
6060604052341561000f57600080fd5b60e58061001d6000396000f30060606040526004361060
```
동일한 정보는 Remix 온라인 컴파일러에서도 얻을 수 있습니다.

이제 트랜잭션을 만들 수 있습니다.  
```
> src = web3.eth.accounts[0];
> faucet_code = \
  "0x6060604052341561000f57600080fd5b60e58061001d6000396000f300606...f0029";
> web3.eth.sendTransaction({from: src, to: 0, data: faucet_code, \
  gas: 113558, gasPrice: 200000000000});

"0x7bcc327ae5d369f75b98c0d59037eec41d44dfae75447fd753d9f2db9439124b"
```
주소가 0인 계약 작성의 경우에도 실수로 이더를 0x0으로 보냈다가 영구적으로 손실되는 비용이 너무 크기 때문에 항상 to 매개 변수를 지정하는 것이 좋습니다.   
또한 gasPrice 및 gasLimit도 지정해야 합니다.

계약이 마이닝되면 Etherscan 블록 탐색기에서 볼 수 있습니다(Etherscan에 표시된 것처럼 성공적으로 마이닝된 계약을 표시합니다.  
![figure](https://github.com/ethereumbook/ethereumbook/raw/develop/images/contract_published.png)  
그림 5. 계약이 성공적으로 채굴되었음을 보여 주는 Ethercan
우리는 계약에 대한 정보를 얻기 위해 거래 영수증을 볼 수 있습니다.  
```
> web3.eth.getTransactionReceipt( \
  "0x7bcc327ae5d369f75b98c0d59037eec41d44dfae75447fd753d9f2db9439124b");

{
  blockHash: "0x6fa7d8bf982490de6246875deb2c21e5f3665b4422089c060138fc3907a95bb2",
  blockNumber: 3105256,
  contractAddress: "0xb226270965b43373e98ffc6e2c7693c17e2cf40b",
  cumulativeGasUsed: 113558,
  from: "0x2a966a87db5913c1b22a59b0d8a11cc51c167a89",
  gasUsed: 113558,
  logs: [],
  logsBloom: \
    "0x00000000000000000000000000000000000000000000000000...00000",
  status: "0x1",
  to: null,
  transactionHash: \
    "0x7bcc327ae5d369f75b98c0d59037eec41d44dfae75447fd753d9f2db9439124b",
  transactionIndex: 0
}
```
이것은 계약서의 주소를 포함하며, 이전 섹션에서와 같이 계약에서 자금을 보내고 받는 데 사용할 수 있습니다.  
```
> contract_address = "0xb226270965b43373e98ffc6e2c7693c17e2cf40b"
> web3.eth.sendTransaction({from: src, to: contract_address, \
  value: web3.utils.toWei(0.1, "ether"), data: ""});

"0x6ebf2e1fe95cc9c1fe2e1a0dc45678ccd127d374fdf145c5c8e6cd4ea2e6ca9f"

> web3.eth.sendTransaction({from: src, to: contract_address, value: 0, data: \
  "0x2e1a7d4d000000000000000000000000000000000000000000000000002386f26fc10000"});

"0x59836029e7ce43e92daf84313816ca31420a76a9a571b69e31ec4bf4b37cd16e"
```
잠시 후, Etherscan에 표시된 것처럼 두 트랜잭션이 모두 Etherscan에서 자금 송수신에 대한 트랜잭션을 볼 수 있습니다.  
![figure 6](https://github.com/ethereumbook/ethereumbook/raw/develop/images/published_contract_transactions.png)  
그림 6. 자금 송수신에 대한 거래를 보여주는 Ethercan  


# Digital Signatures
지금까지 디지털 서명에 대해 자세히 알아보지 못했습니다.   
이 섹션에서는 디지털 서명이 작동하는 방법과 개인 키를 공개하지 않고 개인 키의 소유권 증명을 제공하는 데 사용할 수 있는 방법에 대해 살펴봅니다.  

## The Elliptic Curve Digital Signature Algorithm
Ethereum에서 사용되는 디지털 서명 알고리즘은 ECSA(Elliptic Curve Digital Signature Algorithm)입니다. [Electric_curve]에서 설명한 것처럼 타원 곡선 비공개-공개 키 쌍을 기반으로 합니다.

Ethereum에서는 디지털 서명이 세 가지 용도로 사용됩니다(다음 사이드바 참조). 첫째, 서명은 Ethereum 계정 소유자인 개인 키의 소유자가 이더 지출 또는 계약 실행을 승인했음을 증명합니다. 두 번째로, 그것은 부정할 수 없는 것을 보장한다: 승인 증거는 부인할 수 없다. 셋째, 서명은 거래가 체결된 후 거래자료가 수정되지 않았음을 증명하며, 누구도 수정할 수 없습니다.

위키피디아의 디지털 서명 정의
디지털 서명은 디지털 메시지 또는 문서의 신뢰성을 표시하기 위한 수학적 체계입니다. 유효한 디지털 서명은 수신인에게 메시지가 알려진 발신인(인증)에 의해 작성되었으며, 발신인이 메시지 발송을 거부할 수 없으며(거부되지 않음) 메시지가 전송(무결성) 변경되지 않았다고 믿을 수 있는 이유를 제공합니다.  

Source: https://en.wikipedia.org/wiki/Digital_signature

## How Digital Signatures Work
디지털 서명은 두 부분으로 구성된 수학적 체계입니다.   
첫 번째 부분은 개인 키(서명 키)를 사용하여 메시지(이 경우 트랜잭션)에서 서명을 만드는 알고리즘입니다.   
두 번째는 메시지와 공개 키만으로 누구나 서명을 확인할 수 있는 알고리즘입니다.  

### Creating a digital signature
Ethereum의 ECDSA 구현에서 서명되는 "메시지"는 트랜잭션 또는 더 정확하게는 트랜잭션에서 RLP 인코딩된 데이터의 Kecak-256 해시입니다.   
서명 키는 EOA의 개인 키입니다.   
결과는 다음과 같습니다.  

S i g = F sig ( F keccak256 ( m ) , k )
where:

+ k is the signing private key.  
+ m is the RLP-encoded transaction.  
+ Fkeccak256 is the Keccak-256 hash function.  
+  Fsig is the signing algorithm.  
+  Sig is the resulting signature.  

The function Fsig produces a signature Sig that is composed of two values, commonly referred to as r and s:

S i g = ( r , s )


### Verifying the Signature
서명을 확인하려면 서명(rands), 일련화된 트랜잭션 및 서명을 작성하는 데 사용되는 개인 키에 해당하는 공개 키가 있어야 합니다.   
기본적으로 서명 확인은 "이 공개 키를 생성한 개인 키의 소유자만 이 트랜잭션에서 이 서명을 생성할 수 있었습니다."

서명 확인 알고리즘은 메시지(즉, 사용 중인 트랜잭션의 해시), 서명자의 공용 키 및 서명(r 및 s 값)을 가져오며, 서명이 이 메시지 및 공용 키에 유효한 경우 true를 반환합니다.  

## ECDSA Math
앞에서 언급한 것처럼, 서명은 두 개의 값, r과 s로 구성된 서명을 생성하는 수학 함수 Fsig에 의해 생성됩니다.   
이 섹션에서는 Fsig 기능을 자세히 살펴봅니다.

서명 알고리즘은 먼저 암호화 방식으로 사용 후 삭제(임시) 개인 키를 생성합니다.   
이 임시 키는 송신자의 실제 개인 키가 Ethereum 네트워크에서 서명된 트랜잭션을 감시하는 공격자가 계산하지 못하도록 하기 위해 rands 값 계산에 사용됩니다.

[pubkey]에서 알 수 있듯이, 사용 후 삭제 개인 키는 해당(사용 후 삭제) 공용 키를 도출하는 데 사용됩니다.   
따라서 다음과 같은 기능이 있습니다.  
+ A cryptographically secure random number q, which is used as the ephemeral private key  
+ The corresponding ephemeral public key Q, generated from q and the elliptic curve generator point G  

그러면 디지털 서명의 r 값은 사용 후 삭제 공개 키 Q의 x 좌표입니다.

여기서 알고리즘은 다음과 같이 서명의 s 값을 계산합니다.  
+ s ≡ q-1 (Keccak256(m) + r * k)     (mod p)
where:  
+ q is the ephemeral private key.  
+ r is the x coordinate of the ephemeral public key.  
+ k is the signing (EOA owner’s) private key.  
+ m is the transaction data.  
+ p is the prime order of the elliptic curve.  

검증은 서명 생성 함수의 역순이며, rands 값과 송신자의 공개 키를 사용하여 타원 곡선(서명 작성에 사용되는 사용 후 삭제 공용 키)의 점인 값 Q를 계산합니다.   
단계는 다음과 같습니다.  

1. Check all inputs are correctly formed  
2. Calculate w = s-1 mod p  
3. Calculate u1 = Keccak256(m) * w mod p  
4. Calculate u2 = r * w mod p  
5. Finally, calculate the point on the elliptic curve Q ≡ u1 * G + u2 * K     (mod p)  

Where:  
+ r and s are the signature values.  
+ K is the signer’s (EOA owner’s) public key.  
+ m is the transaction data that was signed.  
+ G is the elliptic curve generator point.  
+ p is the prime order of the elliptic curve.  

계산된 점 Q의 x 좌표가 r과 같으면 검증자는 서명이 유효하다는 결론을 내릴 수 있습니다.  

서명을 확인할 때 개인 키는 알 수도 없고 표시되지도 않습니다.  
|  |  |  
|--|--|  
|팁|ECDSA는 필연적으로 꽤 복잡한 수학 분야이다; 완전한 설명은 이 책의 범위를 벗어난다. 온라인 상의 수많은 훌륭한 가이드들이 단계별로 안내해 드립니다: "ECDSA 설명"을 검색하거나 http://bit.ly/2r0HhGB을 사용해 보십시오.|  


# Transaction Signing in Practice
유효한 트랜잭션을 생성하려면 발신자가 타원 곡선 디지털 서명 알고리즘을 사용하여 메시지에 디지털 서명해야 합니다.   
"sign the transaction"이라는 말은 실제로 "RLP 직렬 트랜잭션 데이터의 Keccak-256 해시 서명"을 의미합니다.   
서명은 트랜잭션 자체가 아니라 트랜잭션 데이터의 해시에 적용됩니다.

Ethereum에서 거래에 서명하려면 발신자가 다음을 수행해야 합니다.  
1. nonce, gasPrice, gasLimit, to, value, data, chain의 9개 필드를 포함하는 트랜잭션 데이터 구조를 만듭니다.아이디, 0, 0.  
2. 트랜잭션 데이터 구조의 RLP 인코딩 직렬화 메시지를 생성합니다.  
3. 이 직렬화된 메시지의 Keccak-256 해시를 계산합니다.  
4. 원래 EOA의 개인 키로 해시에 서명하고 ECSA 서명을 계산합니다.  
5. ECDSA 서명의 계산된 v, r 및 s 값을 트랜잭션에 추가합니다.  

특수 서명 변수 v는 ECDSA 복구 함수가 서명을 확인하는 데 도움이 되는 체인 ID와 복구 식별자의 두 가지를 나타냅니다.   
27 또는 28 중 하나로 계산되거나 체인 ID가 두 배 더하기 35 또는 36으로 계산됩니다.   
체인 ID에 대한 자세한 내용은 EIP-155를 사용한 원시 트랜잭션 생성을 참조하십시오.  
복구 식별자("구식" 서명에서 27 또는 28 또는 전체 Spurious Dragon 스타일 트랜잭션에서 35 또는 36)는 공용 키의 y 구성 요소의 패리티를 나타내는 데 사용됩니다(자세한 내용은 서명 접두사 값(v) 및 공용 키 복구 참조).  
|  |  |  
|--|--|  
|노트|#2,675,000의 Ethereum은 "Spurious Dragon" 하드포크를 구현했으며, 다른 변경사항 중에서도 트랜잭션 재생 보호(한 네트워크에 대해 의미된 트랜잭션이 다른 네트워크에서 재생되는 것을 방지)를 포함하는 새로운 서명 방식을 도입했습니다. 이 새 서명 체계는 EIP-155에 명시되어 있습니다. 이 변경 사항은 트랜잭션의 형태와 서명에 영향을 미치므로 두 가지 형식 중 하나를 취하고 해시되는 트랜잭션 메시지에 포함된 데이터 필드를 나타내는 세 가지 서명 변수(즉, v) 중 첫 번째 변수에 주의해야 합니다.|  


# Raw Transaction Creation and Signing
raw transaction 을 npm 의 ethereumjs-tx 라이브러리르 사인함  
사용자를 대신해서 지갑이나 어플에서 아래와 같이 사인함  
사인한 결과는 아래와 같음  
```
link:code/web3js/raw_tx/raw_tx_demo.js[]
```
예제 코드를 실행하면 다음과 같은 결과가 생성됩니다.  
```
$ node raw_tx_demo.js
RLP-Encoded Tx: 0xe6808609184e72a0008303000094b0920c523d582040f2bcb1bd7fb1c7c1...
Tx Hash: 0xaa7f03f9f4e52fcf69f836a6d2bbc7706580adce0a068ff6525ba337218e6992
Signed Raw Transaction: 0xf866808609184e72a0008303000094b0920c523d582040f2bcb1...
```

## Raw Transaction Creation with EIP-155
EIP-155 "Simple Replay Attack Protection" 표준은 서명하기 전에 트랜잭션 데이터 내부에 체인 식별자를 포함하는 재생 공격 방지 트랜잭션 인코딩을 지정합니다.   
이렇게 하면 한 블록체인에 대해 생성된 트랜잭션(예: Ethereum 메인 네트워크)이 다른 블록체인(예: Ethereum Classic 또는 Ropsten 테스트 네트워크)에서 무효가 됩니다.   
따라서 한 네트워크에서 브로드캐스트되는 트랜잭션은 다른 네트워크에서 재생할 수 없으므로 표준의 이름입니다.

EIP-155는 트랜잭션 데이터 구조의 주요 6개 필드(체인 식별자 0 및 0)에 세 개의 필드를 추가합니다.   
이 세 필드는 트랜잭션 데이터를 인코딩하고 해시하기 전에 트랜잭션 데이터에 추가됩니다.   
따라서 나중에 서명이 적용되는 트랜잭션의 해시를 변경합니다. 서명되는 데이터에 체인 식별자를 포함하면 체인 식별자가 수정되면 서명이 무효화되므로 트랜잭션 서명은 변경을 방지합니다.   
따라서 EIP-155는 서명의 유효성이 체인 식별자에 따라 다르기 때문에 트랜잭션을 다른 체인에서 재생하는 것을 불가능하게 만듭니다.

체인 식별자 필드는 체인 식별자에 설명된 대로 트랜잭션이 사용되는 네트워크에 따라 값을 가져옵니다.  

[Table 1. Chain identifiers]
|Chain	|Chain ID|
|--|--|
|Ethereum mainnet|1|
|Morden (obsolete), Expanse|2|
|Ropsten|3|  
|Rinkeby|4|
|Rootstock mainnet|30|
|Rootstock testnet|31|
|Kovan|42|
|Ethereum Classic mainnet|61|
|Ethereum Classic testnet|62|
|Geth private testnets|1337|

결과 트랜잭션 구조는 RLP 인코딩, 해시 및 서명됩니다.   
서명 알고리즘이 약간 수정되어 v 접두사에서도 체인 식별자를 인코딩합니다.

자세한 내용은 EIP-155 규격을 참조하십시오.  

# The Signature Prefix Value (v) and Public Key Recovery

트랜잭션 구조에서 언급한 것처럼 트랜잭션 메시지에는 "보낸 사람" 필드가 포함되지 않습니다.   
발신자의 공개 키는 ECDSA 서명에서 직접 계산할 수 있기 때문입니다. 공용 키가 있으면 주소를 쉽게 계산할 수 있습니다.   
서명인의 공개 키를 복구하는 과정을 공개 키 복구라고 합니다.

ECSA Math에서 계산된 rands 값을 고려할 때 두 개의 가능한 공개 키를 계산할 수 있습니다.

먼저 서명에 있는 x 좌표 값에서 두 타원 곡선 점 R과 R'을 계산합니다. 타원 곡선이 x축에 걸쳐 대칭이므로 모든 값 x에 대해 곡선에 적합한 두 개의 값(x축의 각 측면에 하나씩)이 있을 수 있습니다.

r에서 우리는 r의 곱셈 역인 r-1도 계산한다.

마지막으로, 메시지 해시의 가장 낮은 비트인 z를 계산합니다.   
여기서 n은 타원 곡선의 순서입니다.

그러면 두 개의 가능한 공개 키는 다음과 같습니다.  

K1 = r^–1 (sR – zG)  
and:  
K2 = r^-1 (sR' – zG)
where:  
K1 and K2 are the two possibilities for the signer’s public key.  
r^-1 is the multiplicative inverse of the signature’s r value.  
s is the signature’s s value.  
R and R' are the two possibilities for the ephemeral public key Q.  
z is the n-lowest bits of the message hash.  
G is the elliptic curve generator point.  

트랜잭션 서명에는 사용 후 삭제 공개 키인 두 개의 R 값 중 어느 것이 가능한지를 알려주는 접두어 값 v가 포함됩니다.   
v가 짝수이면 R이 올바른 값입니다.   
v가 홀수이면 R'입니다.   
그렇게 하면 R은 한 값, K는 한 값만 계산하면 됩니다.  

# Separating Signing and Transmission (Offline Signing)
거래가 서명되면, Ethereum 네트워크로 전송할 준비가 됩니다.   
트랜잭션을 만들고 서명하고 브로드캐스트하는 세 가지 단계는 일반적으로 web3.eth.sendTransaction을 사용하는 것과 같이 단일 작업으로 수행됩니다.   
그러나 원시 트랜잭션 작성 및 서명에서 볼 수 있듯이 트랜잭션은 두 단계로 작성 및 서명할 수 있습니다.   
서명된 트랜잭션이 있으면 web3.eth.SendTransaction을 사용하여 전송할 수 있습니다.  
sendTransaction은 16진수 인코딩 및 서명된 트랜잭션을 가져와 Ethereum 네트워크를 통해 전송합니다.

거래의 서명과 전송을 분리하려는 이유는 무엇입니까? 가장 흔한 이유는 보안입니다.   
트랜잭션에 서명하는 컴퓨터에는 잠금 해제된 개인 키가 메모리에 로드되어 있어야 합니다.   
전송을 수행하는 컴퓨터는 인터넷에 연결되어 있어야 하며 Ethereum 클라이언트를 실행하고 있어야 합니다.   
이 두 기능이 한 컴퓨터에 있으면 온라인 시스템에 개인 키가 있는 것입니다. 상당히 위험합니다.   
서로 다른 컴퓨터(오프라인과 온라인 기기)에서 각각 서명과 전송, 수행하는 기능을 분리하는 것을 오프라인 서명이라고 하며 일반적인 보안 관행입니다.

1. Ethereum 트랜잭션의 오프라인 서명에는 다음 프로세스가 표시됩니다.
계정의 현재 상태, 특히 사용 가능한 자금 상태를 검색할 수 있는 온라인 컴퓨터에 서명되지 않은 트랜잭션을 만듭니다.  

2. 서명되지 않은 트랜잭션을 QR 코드 또는 USB 플래시 드라이브와 같은 트랜잭션 서명을 위해 "에어갭" 오프라인 장치로 전송합니다.  

3. 서명된 트랜잭션(뒤로)을 온라인 장치로 전송하여 QR 코드 또는 USB 플래시 드라이브를 통해 Ethereum 블록체인을 통해 브로드캐스트합니다.  

![offline signing](https://github.com/ethereumbook/ethereumbook/raw/develop/images/offline_signing.png)  
그림 7. Ethereum 트랜잭션의 오프라인 서명  
필요한 보안 수준에 따라 "오프라인 서명" 컴퓨터는 격리된 방화벽 서브넷(온라인이지만 분리된 서브넷)에서 에어갭 시스템이라고 하는 완전히 오프라인 시스템에 이르기까지 온라인 컴퓨터로부터 다양한 수준의 분리를 가질 수 있습니다.   
에어 갭 시스템에서는 네트워크 연결이 전혀 없습니다.   
컴퓨터가 온라인 환경과 "공기"의 갭으로 분리되어 있습니다.   
거래에 서명하려면 데이터 저장 매체 또는 (더 나은) 웹캠과 QR 코드를 사용하여 에어갭 컴퓨터로 전송하거나 컴퓨터에서 전송해야 합니다.   
물론 서명할 모든 트랜잭션을 수동으로 전송해야 하지만, 이 작업은 확장되지 않습니다.

완전히 공기로 연결된 시스템을 활용할 수 있는 환경은 많지 않지만, 적은 수준의 격리에도 상당한 보안 이점이 있습니다.   
예를 들어 메시지 대기열 프로토콜만 통과할 수 있는 방화벽이 있는 격리된 서브넷은 온라인 시스템의 서명보다 훨씬 더 낮은 공격 표면과 훨씬 높은 보안을 제공할 수 있습니다.   
이를 위해 ZeroMQ(0MQ)와 같은 프로토콜을 사용하는 기업이 많다.   
이와 같은 설정을 사용하면 트랜잭션이 직렬화되고 서명 대기 상태가 됩니다.   
큐 프로토콜은 TCP 소켓과 유사한 방식으로 직렬화된 메시지를 서명 컴퓨터로 전송합니다.   
서명 컴퓨터는 대기열에서 직렬화된 트랜잭션을 주의 깊게 읽고 적절한 키를 사용하여 서명을 적용한 후 나가는 대기열에 배치합니다.   
나가는 큐는 서명된 트랜잭션을 대기 중인 Ethereum 클라이언트가 있는 컴퓨터로 전송하여 전송합니다.  

# Transaction Propagation
Ethereum 네트워크는 "flood 라우팅" 프로토콜을 사용합니다.   
각 Ethereum 클라이언트는 (이상적으로) 메쉬 네트워크를 형성하는 P2P(Peer-to-Peer) 네트워크에서 노드 역할을 합니다.   
특별한 네트워크 노드는 없습니다. 모두 동일한 피어 역할을 합니다.   
P2P 네트워크에 연결되어 참여하고 있는 Ethereum 클라이언트를 지칭하기 위해 "노드"라는 용어를 사용할 것입니다.

트랜잭션 전파는 원래 Ethereum 노드가 서명된 트랜잭션을 만들거나 오프라인에서 수신하는 것으로 시작됩니다.   
트랜잭션은 유효성을 검사한 다음 원래 노드에 직접 연결된 다른 모든 Ethereum 노드로 전송됩니다.   
평균적으로 각 Ethereum 노드는 인접 노드라고 하는 최소 13개의 다른 노드에 대한 연결을 유지합니다.   
각 인접 노드는 트랜잭션을 수신하는 즉시 유효성을 검사합니다.   
복사본이 유효하다고 동의하면 복사본을 저장하고 가져온 복사본을 제외한 모든 이웃에 전파합니다.   
결과적으로 트랜잭션은 원래 노드에서 외부로 리플링되어 네트워크를 통해 플러딩되며 네트워크의 모든 노드가 트랜잭션의 복사본을 가질 때까지 리플링됩니다.   
노드는 전파하는 메시지를 필터링할 수 있지만 기본값은 수신하는 모든 유효한 트랜잭션 메시지를 전파하는 것입니다.  

단 몇 초 만에 Ethereum 트랜잭션이 전 세계의 모든 Ethereum 노드에 전파됩니다. 각 노드의 관점에서 트랜잭션의 출처를 식별할 수 없습니다.   
이를 노드로 보낸 인접 네트워크가 트랜잭션의 발신자이거나 인접 네트워크 중 하나로부터 수신했을 수 있습니다.   
트랜잭션의 원점을 추적하거나 전파를 방해하려면 공격자가 모든 노드의 상당 부분을 제어해야 합니다.   
이는 특히 블록체인 네트워크에 적용되는 P2P 네트워크의 보안 및 개인 정보 보호 설계의 일부입니다.  

# Recording on the Blockchain
Ethereum의 모든 노드가 동일한 피어이지만 일부는 마이너에 의해 운영되며 고성능 그래픽 처리 장치(GPU)를 갖춘 컴퓨터인 마이닝 팜에 트랜잭션과 블록을 공급하고 있다.   
마이닝 컴퓨터는 후보 블록에 트랜잭션을 추가하고 후보 블록을 유효하게 만드는 작업 증명을 찾습니다.   
이에 대한 자세한 내용은 [합의]에서 다루겠습니다.

너무 자세히 설명하지 않으면 결국 유효한 트랜잭션이 거래 블록에 포함되고, 따라서 이더리움 블록체인에 기록됩니다.  
일단 블록으로 채굴되면 거래는 계좌의 잔액을 수정하거나(단순 지급의 경우) 내부 상태를 변경하는 계약을 실행하여 Ethereum 싱글톤의 상태도 수정한다.   
이러한 변경은 거래와 함께 거래 영수증 형태로 기록되며, 사건도 포함될 수 있다.   
우리는 이 모든 것을 [evm_chapter]에서 더 자세히 검토할 것이다.  

생성부터 EOA 서명, 전파, 최종 채굴까지 모든 과정을 마친 거래가 싱글톤의 상태를 변화시키고 블록체인에 지울 수 없는 흔적을 남겼다.  

# Multiple-Signature (Multisig) Transactions
비트코인의 스크립팅 기능에 익숙하다면 여러 당사자가 서명해야 자금을 사용할 수 있는 비트코인 멀티시그 계정을 만들 수 있습니다(예: 서명 4개 중 2개 또는 3개).   
Ethereum의 기본 EOA 가치 거래에는 여러 서명에 대한 조항이 없습니다.   
그러나 임의 서명 제한은 사용자가 생각할 수 있는 조건을 가진 스마트 계약을 통해 이더와 토큰의 전송을 모두 처리할 수 있습니다.

이 기능을 활용하려면 이더를 다중 서명 요구 사항이나 지출 한도(또는 두 가지 조합)와 같이 원하는 지출 규칙으로 프로그래밍된 "지갑 계약"으로 이전해야 합니다.   
그런 다음 지갑 계약은 지출 조건이 충족되면 공인 EOA의 요청이 있을 때 자금을 보냅니다.   
예를 들어, 멀티시그 조건에서 이더를 보호하려면 멀티시그 계약으로 이더를 전송합니다.
다른 계좌로 자금을 보내려면 필요한 모든 사용자가 일반 지갑 앱을 사용하여 계약서에 거래를 보내야 하므로 최종 거래를 수행할 수 있는 계약을 효과적으로 승인해야 합니다.  

이러한 계약은 로컬 코드를 실행하기 전에 여러 서명을 요구하거나 다른 계약을 트리거하도록 설계될 수도 있습니다.   
스키마의 보안은 궁극적으로 멀티시그 계약 코드에 의해 결정됩니다.

멀티 시그니처 트랜잭션을 스마트 계약으로 구현할 수 있는 기능은 Ethereum의 유연성을 보여줍니다.   
그러나 유연성이 강화되면 다중 서명 방식의 보안을 해치는 버그가 발생할 수 있기 때문에 양날의 칼이다.   
사실, 적어도 단순한 N-M-of-N 다중 서명 체계에 대해 스마트 계약의 필요성을 제거하는 다중 서명 명령을 EVM에 만들자는 다수의 제안이 있다.   
이는 핵심 컨센서스 규칙의 일부인 비트코인의 다중 서명 시스템과 맞먹는 것으로, 견고하고 안전하다는 것이 입증됐다.  

# Conclusions
트랜잭션은 이더리움 시스템의 모든 활동의 시작점임  
트랜잭션은 EVM 컨트랙트를 평가하고, 잔고를 업데이트하며, 이더리움 블록체인을 상태를 변경하는 통로이다  
다음 챕터에서는 Solidity 에 대해서 자세히 알아 본다  


